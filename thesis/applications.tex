\chapter{Applications} \label{chap:applications}

\section{A tactic to replace the built-in add clause action}\label{sec:addClause}

We have seen in \autoref{chap:introduction} how the ``Add initial match clause
to type declaration'' editor action works. When the cursor is on the type
signature of a function that does not have any clauses, we can run this editor
action and get an initial clause for the function.

In this section we implement this editor action for top-level type
declarations, using edit-time tactics. The Idris code we need to write is in
\autoref{code:addClause}.

\begin{figure}[ht]
\caption{Implementation of the edit-time tactic for ``add clause''.}
\label{code:addClause}
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\fn{collectTypes} : \ty{TT} -> (\bn{xs} : \ty{List} \ty{TT} \dt{**} \ty{NonEmpty} \bn{xs})
\fn{collectTypes} (\dt{Bind} _ (\dt{Pi} \bn{ty} _) \bn{t}) =
  (\bn{ty} \fn{::} \bn{fst} (\fn{collectTypes} \bn{t}) ** \dt{IsNonEmpty})
\fn{collectTypes} \bn{t} = (\dt{[}\bn{t}\dt{]} ** \dt{IsNonEmpty})

\kw{%editor}
\fn{addClause} : \ty{TTName} -> \ty{Elab} (\ty{FunClause} \ty{TT})
\fn{addClause} \bn{n} =
  \kw{do} (_, _, \bn{ty}) <- \fn{lookupTyExact} \bn{n}
     \kw{let} (\bn{collected} \dt{**} \bn{nonEmpty}) = \fn{collectTypes} \bn{ty}
     \kw{let} (\bn{argTys}, \bn{retTy}) = (\fn{init} \bn{collected}, \fn{last} \bn{collected})
     \bn{argNames} <- \fn{traverse} (\fn{const} \fn{fresh}) \bn{argTys}
     \kw{let} \bn{lhsUntyped} = \fn{foldl} \dt{RApp} (\dt{Var} \bn{n}) (\fn{map} \dt{Var} \bn{argNames})
     \bn{env} <- \fn{getEnv}
     (lhsTyped, _) <- \fn{check} \bn{env} \bn{lhsUntyped}
     \bn{holeName} <- \fn{fresh}
     \kw{let} \bn{rhs} = \dt{Bind} \bn{holeName} (\dt{GHole} \bn{retTy}) (\dt{V} \dt{0})
     \fn{pure} (\bn{MkFunClause} \bn{lhsTyped} \bn{rhs})
\end{Verbatim}
\end{figure}

The \fn{collectTypes} function we write in Idris is very similar to the one we
defined in \autoref{code:collectTypes} for the compiler implementation.
This one, however, also returns a proof that the resulting list is not empty.
The function takes a list and you the same list with the last element removed,
namely \fn{init}, requires a proof that the list be non-empty.

\TODO{Finish explaining code}

\TODO{Talk about the Emacs lisp part}


\section{Theorem prover for intuitionistic propositional logic}\label{sec:hezarfen}

In this section, we describe the tactic Hezarfen\footnote{ The name is
  pronounced {[\textipa{hezaRf\ae n}]}, like ``has are fan'', and it means
    polymath in Turkish.  Tactic source code is available at
    \url{http://github.com/joom/hezarfen}.}, which can decide intuitionistic
propositional logic theorems.

This tactic will be based on LJT\cite{ljt} and its Haskell
implementation Djinn\cite{djinn}, which generates Haskell expressions
for a given type.

However, Djinn is a standalone program that takes commands
interactively, and when it generates an expression it prints it on the screen.
Instead we want to design Hezarfen as a library that provides an \Elab\ action
that can be used as a tactic in proofs, and also as a custom editor action that
helps us when the built-in proof search mechanism does not suffice.

Using this library, we want to define the \Elab\ action we used in
\autoref{sec:communication}, with the type
\texttt{\fn{prover} : \ty{TTName} -> \ty{Elab} \ty{TT}}.
This tactic takes the name of the hole it is supposed to fill, and gives back a
\TT\ term in the \Elab\ monad.

Since Hezarfen's proof terms are send back to the editor and put back into the
source code, we should aim to make our proof terms as simple as possible.
Hence we should implement both proof term generation, and simplification.

\subsection{Proof term generation}

\TODO{Explain how the tactic works, especially the nested implication rule which is a bit confusing.}

% explain the nested impl rule in depth
% and possibly one or two more, to show what they look like in general

\subsection{Simplification}

In \texttt{Hezarfen.Simplify}, we define a function \fn{reduce} that simplifies
a given \Raw\ term into another \Raw\ term in the \Elab\ monad.\footnote{We
depend on the \Elab\ monad for fresh name generation.}
A rudimentary implementation of this function that does not include all the
simplification steps is given in \autoref{code:reduce}.

\begin{figure}[ht]
\caption{Rudimentary implementation of \fn{reduce} in Hezarfen.}
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\fn{reduce} : \ty{Raw} -> \ty{Elab} \ty{Raw}
\fn{reduce} \fn{t} = \kw{case} \bn{t} \kw{of}
  \cm{-- Eta reduction:  (\textbackslash{}x => f x) becomes f}
  \dt{RBind} \bn{n} (\dt{Lam} \bn{b}) (\dt{RApp} \bn{t'} (\dt{Var} \bn{n'})) =>
    \kw{if} \bn{n} \fn{==} \bn{n'}
      \kw{then} \fn{reduce} \bn{t'}
      \kw{else} \fn{pure} \fn{$} \dt{RBind} \bn{n} (\dt{Lam} \bn{b}) !(\fn{reduce} (\dt{RApp} !(\fn{reduce} \bn{t'}) (\dt{Var} \bn{n'})))

  \cm{-- (id x) becomes x}
  \dt{RApp} (\dt{RApp} (\dt{Var} \kw{\`{}\{}\fn{id}\kw{\}}) \bn{c}) \bn{x} => \fn{reduce} \bn{x}

  \dt{RBind} \bn{n} \bn{b} \bn{t'} => \fn{pure} \fn{$} \dt{RBind} \bn{n} \bn{b} !(\fn{reduce} \bn{t'})
  \dt{RApp} \bn{t1} \bn{t2} => \fn{pure} \fn{$} \dt{RApp} !(\fn{reduce} \bn{t1}) !(\fn{reduce} \bn{t2})
  _ => \fn{pure} \bn{t}
\end{Verbatim}
\end{figure}

In the full implementation, we do more complex simplifications, such as
simplifying \texttt{(\textbackslash{}\bn{x} => \fn{g} (\fn{f} \bn{x}))} into
\texttt{(\fn{g} \fn{.} \fn{f})}, removing unused \kw{let} bindings,
substituting a \kw{let} binding in the body if the binding is only used once,
etc.

To fully simplify a \Raw\ term, we repeatedly apply it to \fn{reduce} until
fixpoint, which should be improved in future work.

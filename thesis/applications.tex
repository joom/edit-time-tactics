\section{Applications} \label{sec:applications}

\subsection{Theorem Prover for Intuitionistic Propositional Logic}

In this section, we describe the tactic Hezarfen\footnote{Tactic source code
can be found at \url{http://github.com/joom/hezarfen}.}, which can decide
intuitionistic propositional logic theorems. This is based on LJT\cite{ljt}
and its Haskell implementation called Djinn\cite{djinn}, which generates
Haskell expressions for a given type. However Djinn is a standalone program
that takes commands interactively, and when it generates an expression it
prints it on the screen.

Even without the editor interaction in mind, we can improve this by having our
theorem prover generate Idris expressions of the type \path{Raw}, one of the
types used for the inner representation of the core language of Idris.
We can then write a tactic that takes the goal type, which will of the
\path{Raw}, and tries to fill the hole with the generated term.
Let's prove a theorem using this tactic:

\begin{Verbatim}
\IdrisFunction{noContradiction} : \IdrisFunction{Not} \IdrisType{(}\IdrisImplicit{p}\IdrisType{,} \IdrisFunction{Not} \IdrisImplicit{p}\IdrisType{)}
\IdrisFunction{noContradiction} = \IdrisKeyword{\%runElab} \IdrisFunction{hezarfen}
\end{Verbatim}

Through the elaborator reflection, that will turn into this:\footnote{
  Variables are renamed in the resulting definition above for presentation
  purposes. Hezarfen is not very clever with naming variables. It just keeps
  calling \path{gensym} with the same hint string, which means all names are
  of the form \path{MN} \path{101} \path{"x"}, where the number is increased
  for each machine generated name. However the expression is not
  changed otherwise. The definition could simply be written as

\ttfamily{\IdrisFunction{noContradiction} \IdrisData{(}\IdrisBound{pfOfP}\IdrisData{,} \IdrisBound{pfOfNotP}\IdrisData{)} = \IdrisFunction{void} (\IdrisBound{pfOfNotP} \IdrisBound{pfOfP})} }
\begin{Verbatim}
\IdrisFunction{noContradiction} : \IdrisFunction{Not} \IdrisType{(}\IdrisImplicit{p}\IdrisType{,} \IdrisFunction{Not} \IdrisImplicit{p}\IdrisType{)}
\IdrisFunction{noContradiction} = \textbackslash\IdrisBound{pair} =>
      \IdrisKeyword{let} \IdrisBound{pfOfP} = \IdrisFunction{fst} \IdrisBound{pair} \IdrisKeyword{in}
      \IdrisKeyword{let} \IdrisBound{pfOfNotP} = \IdrisFunction{snd} \IdrisBound{pair} \IdrisKeyword{in}
      (\textbackslash\IdrisBound{x} => \IdrisFunction{void} \IdrisBound{x}) (\IdrisBound{pfOfNotP} \IdrisBound{pfOfP})
\end{Verbatim}


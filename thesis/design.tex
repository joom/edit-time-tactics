\section{Design}\label{sec:design}
The goal of this project is to allow users to write custom editor actions using
elaborator reflection.
The editor and the compiler have to communicate to do that; the editor must
send the name of the action and the necessary information for that, and the
compiler should then send the result back.
In this chapter, we will look at how the built-in editor actions work, and then
see what kind of restrictions this brings, and how this shapes the design of
edit-time tactics.

\subsection{Communication}\label{ssec:communication}

The current Idris implementation\footnote{This thesis is using Idris 1.2.0.} of
the editor interaction mode is a part of the Idris compiler, and is written in
Haskell.
The editor runs an instance of the \texttt{idris} executable with the
\texttt{--ide-mode} flag, which
allows socket communication with the program through a machine-readable
syntax.\footnote{The Idris mode of Vim works differently, since Vim did not
support asynchronous jobs until version 8.0. This should change in the near future.}
To be more precise, the compiler receives S-expressions\cite{mccarthy} as input
over the socket and sends back S-expressions as output.

Let's the editor actions we looked at in \autoref{sec:introduction}.
We have the following piece of code, which is meant to be the height function
on binary trees at the end. The next step is to add a the initial function clause.

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\IdrisFunction{height} : \IdrisType{Tree} \bn{a} -> \IdrisType{Nat}
\end{Verbatim}

When we put the cursor on \fn{height} and run the action to add the initial
function clause, the editor sends the message on the first line to the
compiler, after doing the necessary computation, the compiler responds with the
message on the second line:

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{S-expression}}, labelposition=topline]
-> ((:add-clause 4 "height") 8)
<- (:return (:ok "height t1 = ?height_rhs") 8)
\end{Verbatim}

Let's look at how these messages are formed. The built-in add clause command
needs to know the line number after which we are adding a clause, which is
\texttt{5}, and the name of the function we are adding a clause for, which is
\bn{height}.
Also, for communication purposes, we keep track of how many rounds of
communications have been done so far. The number \texttt{8} we have at the end
of the message signifies that this is the 8th correspondence so far.
Observe that the response also carries the same number.

The response contains \texttt{:ok}, which means the clause adding succeeded,
and then a string that contains a line of code.
When the editor receives that, it adds this new code to the next
line. Note that that last step is done by the front-end of the editor
interaction mode, i.e. in Emacs Lisp if we are in Emacs.

The next step in writing the function \fn{height} is to look at the possible
cases of the tree, i.e. a case splitting action. This is the piece of code we
have before that action:

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\IdrisFunction{height} : \IdrisType{Tree} \bn{a} -> \IdrisType{Nat}
\IdrisFunction{height} \IdrisBound{t1} = \hole{height_rhs}
\end{Verbatim}

When we put the cursor on \bn{t1} and run the case splitting action, this is
the communication that happens between the editor and the compiler.

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{S-expression}}, labelposition=topline]
-> ((:case-split 5 "t1") 11)
<- (:return (:ok
     "height Empty = ?height_rhs_1{\textbackslash}n
      height (Node x t1 t2) = ?height_rhs_2{\textbackslash}n") 11)
\end{Verbatim}

The built-in case split command needs to know the line number on which we are
case splitting, which is \texttt{5}, and the name of the argument we are
splitting, which is \bn{t1}.  The response contains \texttt{:ok}, which means
the case splitting succeeded, and then a string that contains two lines split
by the new line character. When the editor receives this information, it
replaces the line the cursor was on before with the new code it received.

We have now seen how exactly the current editor action communication between
the editor and the compiler works through S-expressions.
Now we want to introduce an S-expression format that can capture any of these
commands; we want to generalize the ones we have seen so far.

Suppose we have the following \Elab\ action that we want to run from the editor:
\texttt{\fn{prover} : \ty{TTName} -> \ty{Elab} \ty{TT}}.
We will see in detail in \autoref{ssec:hezarfen} how this tactic is
implemented. For now let's only look at how it is used. It takes a name of a
hole, and returns the proof term to fill the hole with.
Let's try to prove a trivial lemma with this tactic.

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\fn{f} : \ty{Either} \ty{Unit} \ty{Void}
\fn{f} = \hole{q}
\end{Verbatim}

When we put the cursor on \hole{q} and tell the editor to run the \fn{prover}
tactic, we have to convey a couple things to the compiler: We have to tell that
we want to run an \Elab\ action named \fn{prover}, and we are running this on
the hole \hole{q}, and where exactly the cursor is (in line and column numbers)
when we run this editor action. Here is the communication we want to have for this:

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{S-expression}}, labelposition=topline]
-> ((:elab-edit "prover" '("q") 21 5) 22)
<- (:return (:ok "Left ()") 22)
\end{Verbatim}

The editor tells the compiler that we want to run an \Elab\ action named
\fn{prover}. But the actions we may want to run take arguments, therefore we
pass a list S-expression \texttt{'("q")} that corresponds to the arguments
\fn{prover} takes.

\subsection{Types of editor actions}\label{ssec:types}

Users of our work will write \Elab\ actions that will then be called from the
editor via S-expressions that are sent to the compiler. We outlined above that
in the S-expression, we need to pass the arguments of the specific
\Elab\ action we want to call. Since we have to be able to send the arguments
in an S-expression and also send the result back in another S-expression, we
have limits on what kind of arguments an S-expression can take.
In other words, all arguments and the result of an \Elab\ editor action
have to serializable and deserializable.

Since serialization is done via S-expressions, we need to reflect the type of
S-expressions to Idris.

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\kw{data} \ty{SExp} : \ty{Type} \kw{where}
  \dt{SExpList} : \ty{List} \ty{SExp} -> \ty{SExp}
  \dt{StringAtom} : \ty{String} -> \ty{SExp}
  \dt{BoolAtom} : \ty{Bool} -> \ty{SExp}
  \dt{IntegerAtom} : \ty{Integer} -> \ty{SExp}
  \dt{SymbolAtom} : \ty{String} -> \ty{SExp}
\end{Verbatim}

An S-expression is either an atom of string, boolean, integer, or symbol (such
as \texttt{:example-symbol}), or a list of S-expressions.
For example, the S-expression \texttt{'("q")} will be represented in Idris, as
\dt{SExpList [StringAtom "q"]}.

Going back to the serialization problem, for the argument and return types or
our \Elab\ editor actions, we should specify how they should be converted to
\ty{SExp}s.  Defining certain functions on a type sounds like the perfect task
for Idris interfaces\footnote{Haskell's type classes are called interfaces in
Idris, and type class instances are called implementations.}.
Therefore we define the interface \ty{Editorable}, which tells us
how to serialize a given type into an SExp and how to deserialize it.

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\kw{interface} \ty{Editorable} \bn{a} \kw{where}
  \fn{fromEditor} : \ty{SExp} -> \ty{Elab} \bn{a}
  \fn{toEditor} : \bn{a} -> \ty{Elab} \ty{SExp}
\end{Verbatim}

We have two functions \fn{fromEditor} and \fn{toEditor} that must be defined
for a type that we want to make serializable.
\fn{fromEditor} allows us to deserialize a given S-expression into a value of the type \bn{a}.
\fn{toEditor} allows us to serialize a value of the type \bn{a} into an S-expression.
Notice that both of these functions return a value in the \Elab\ monad.
There are a few reasons for this:
\begin{itemize}
  \item The \Elab\ monad captures failure. Especially the \fn{fromEditor}
    function, which basically parses S-expressions, we want to fail if we are
    given an S-expression that is ill-formed for the type \bn{a}.
  \item The \Elab\ monad has an \ty{Alternative} instance, which allows us to
    recover from failure if we need to.
  \item When an \Elab\ action fail with an explicit use of
    \texttt{\fn{fail} : \ty{List ErrorReporPart} -> \ty{Elab} \bn{a}},
    the user can give a detailed account of why it failed through the pretty
    printed errors. This is useful for giving graceful error messages to the
    user when a custom editor action fails.
  \item Both for serialization and deserialization, users may want to limit it
    to some of the constructors of a type. Being able to fail for certain
    constructors gives the users flexibility.
  \item Why we specifically need \Elab\ instead of any other monad that can
    fail, is that users may want to type check or normalize terms, or look up
    information about existing types and functions during serialization and
    deserialization as well. This is only available in the \Elab\ monad.
\end{itemize}

\subsubsection{\ty{Editorable} implementations in Idris}

Now that we have justified why putting \fn{fromEditor} and \fn{toEditor}
in the \Elab\ monad is necessary,
let's see how we can define an \ty{Editorable} implementation for \ty{String}.

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\kw{implementation} \ty{Editorable} \ty{String} \kw{where}
  \fn{fromEditor} (\dt{StringAtom} \bn{s}) = \fn{pure} \bn{s}
  \fn{fromEditor} \bn{x} =
    \fn{fail} \dt{[}\dt{TextPart} (\dt{"Can't parse the SExp "} \fn{++} \fn{show} \bn{x} \fn{++} \dt{" as a String"})\dt{]}
  \fn{toEditor} = \fn{pure} \fn{.} \dt{StringAtom}
\end{Verbatim}

The definition of \fn{fromEditor} above tells us that if an S-expression is a
string atom, then we know how to get a \ty{String} from that, otherwise we
fail.  On the other hand, \fn{toEditor} never fails; if we have a \ty{String}
we can always construct a \dt{StringAtom} and put it in the \Elab\ monad.

Now, for a more complex example, let's look at how we can make \ty{List}s \ty{Editorable}.

\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\kw{implementation} \ty{Editorable} \bn{a} => \ty{Editorable} (\ty{List} \bn{a}) \kw{where}
  \fn{fromEditor} (\dt{SExpList} \bn{xs}) = \fn{traverse} \fn{fromEditor} \bn{xs}
  \fn{fromEditor} \bn{x} =
    \fn{fail} \dt{[}\dt{TextPart} (\dt{"Can't parse the SExp "} \fn{++} \fn{show} \bn{x} \fn{++} \dt{" as a List"})\dt{]}
  \fn{toEditor} \bn{xs} = \dt{SExpList} \fn{<$>} \fn{traverse} \fn{toEditor} \bn{xs}
\end{Verbatim}

The definition of \fn{fromEditor} above tells us that if we have a list
S-expression, which holds an Idris list \bn{xs} of non-deserialized
S-expressions inside, we can apply \fn{fromEditor} to each of the S-expressions
in \bn{xs} and deserialize them all, and if they all succeed we can make a list
from their results and return that.
Similarly, the definition of \fn{toEditor} above tells us that if we have an
actual list \bn{xs}, we can \fn{traverse} the list to serialize them all, and
if they all succeed, we can make an S-expression out of the serialized
elements.

Now, let's look \autoref{code:ttnameEditorable} to see how we can serialize and
deserialize one of the types that we expect to use the most in our editor
actions, the type of names, \ty{TTName}.

\begin{figure}[ht]
\caption{The \ty{Editorable} implementation for the type \ty{TTName}.}
\label{code:ttnameEditorable}
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\kw{implementation} \ty{Editorable} \ty{TTName} \kw{where}
  \fn{fromEditor} (\dt{StringAtom} \bn{s}) = \fn{namify} \bn{s}
    \kw{where}
      \fn{namify} : \ty{String} -> \ty{Elab} \ty{TTName}
      \fn{namify} \bn{s} =
        \kw{case} \fn{reverse} (\fn{map} \fn{pack} (\fn{splitOn} \dt{'.'} (\fn{unpack} \bn{s}))) \kw{of}
          \dt{[]} => \fn{fail} \dt{[TextPart "Empty string can't be a TTName"]}
          \dt{[}\bn{x}\dt{]} => \fn{pure} (\dt{UN} \bn{x})
          (\bn{x} \dt{::} \bn{xs}) => \bn{pure} (\dt{NS} (\dt{UN} \bn{x}) \bn{xs})
  \fn{fromEditor} \bn{x} =
    \fn{fail} \dt{[}\dt{TextPart} (\dt{"Can't parse the SExp "} \fn{++} \fn{show} \bn{x} \fn{++} \dt{" as a TTName"})\dt{]}

  \fn{toEditor} \bn{n} = \dt{StringAtom} \fn{<$>} \fn{stringify} \bn{n}
    \kw{where}
      \fn{stringify} : \ty{TTName} -> \ty{Elab} \ty{String}
      \fn{stringify} (\dt{UN} \bn{x}) = \fn{pure} \bn{x}
      \fn{stringify} (\dt{NS} \bn{x} \dt{[]}) = \fn{stringify} \bn{x}
      \fn{stringify} (\dt{NS} \bn{x} \bn{xs}) =
        \fn{pure} (\fn{concat} (\fn{intersperse} \dt{"."} (\fn{reverse} (\dt{""} \fn{::} \bn{xs})))
              \fn{++} !(\fn{stringify} \bn{x}))
      \fn{stringify} (\dt{MN} \bn{i} \bn{x}) = \fn{pure} (\dt{"__"} \fn{++} \bn{x} \fn{++} \fn{show} \bn{i})
      \fn{stringify} \bn{n'}@(\dt{SN} \bn{sn}) =
        \fn{fail} [ \dt{TextPart} \dt{"Don't know how to make"}
             , \dt{NamePart} \bn{n'}, \dt{TextPart} \dt{"into StringAtom"}]
\end{Verbatim}
\end{figure}

This is long code excerpt, and you do not have to follow the code entirely.
We will summarize the code below, but this excerpt should demonstrate that
we can define one of the most pivotal parts of serialization in Idris itself,
without writing any Haskell code.

Here is an overview of what \autoref{code:ttnameEditorable} does: When we want
to deserialize a name, we require it to be a \dt{StringAtom}, and then we split
the string \bn{s} on the dots it contains. If there is no dot inside, we make
it a \ty{TTName} without a namespace using \dt{UN}, if there are dots inside,
we make it a \ty{TTName} with a namespace using \dt{NS}. Similarly, if we have
a \ty{TTName}, we check if we are given a namespace by looking at the
constructors of \ty{TTName}. If we are, then we make a \ty{String} the name
with dots in between, if we are not, then we merely make \ty{String} from what
we have.
For the machine generated names, for now, we make up a representation, that we
hope will not clash will other names.
We fail for the special names. Editor tactics will ideally not use names with
\dt{MN} and \dt{SN}, so this is a temporary fallback solution.

\subsubsection{Primitive \ty{Editorable} implementations}

% The \ty{Editorable} implementations we have seen so far are sufficient to


\section{Design}\label{sec:design}

We described in \autoref{sec:introduction} what a simple editor interaction
action like case splitting does.  What we want to do is to add another command
that would be recognized by our compiler, and specify how such a command would
run, and what arguments it should take to communicate with the editor
effectively.

The current Idris\footnote{This thesis is using Idris 1.1.1.} implementation of
the editor interaction mode is a part of the Idris compiler, and is written in
Haskell. When the editor is running,
it runs the \path{idris} executable with the \path{--ide-mode} flag, which
allows socket communication with the program through a machine-readable
syntax.\footnote{The Idris mode of Vim works differently, since Vim did not
support asynchronous jobs until 8.0. This is expected to change in the near
future.}
To be more precise, this program receives S-expressions\cite{mccarthy} as input
over the socket and sends back S-expressions as output. Let's see an example of
this. Suppose we are writing a predecessor function on natural numbers and we
want to case split on the argument.

\begin{Verbatim}
\IdrisFunction{pred} : \IdrisType{Nat} -> \IdrisType{Nat}
\IdrisFunction{pred} \IdrisBound{x} = \IdrisMetavar{?\IdrisMetavar{p}}
\end{Verbatim}

When we put the cursor on \path{x} and run case splitting, the following
communication happens in the background.

\begin{Verbatim}
-> ((:case-split 5 "x") 13)
<- (:return (:ok "pred Z = ?p_1{\textbackslash}npred (S k) = ?p_2{\textbackslash}n") 13)
\end{Verbatim}

Case split command requires two arguments, the line number and the variable
name to case split on. The line number is included in most editor actions that
change the code. The variable name is a string that hold the necessary data.
The number \path{13} that comes afterwards is how many rounds of communications
have been done so far. Notice that the response also carries the same number.
The response contains \path{:ok}, which means the case splitting succeeded,
and then a string that contains two lines split by the new line character.
The editor receives twose two lines and replaces that with the line we ran the
case split command on.

The most important thing to notice here is that the way the editor and the
compiler communicate is very ``stringly typed''\footnote{A term coined by Mark
Simpson, mentioned in a deleted Stack Overflow thread.}.  Since all of these
editor actions are primitives, this is initially fine. However, we now want to
create a single command that handles different kinds of actions. These actions
possibly take multiple arguments that hold different kinds of values, such as
names, type declarations, function definitions, or expressions.
The data itself can still be sent as a string by the editor, but having type
annotations would give a hint to the compiler about how to parse the given
string into parts of a syntax tree. In other words, the command should take a
list of strings, each tagged with a type annotation.

Then the question is, how will the editor know what to tag each string with?
It will not. For each non-trivial editor action, the user will have to extend
the Idris mode of the editor with a function that tags each string with a type
annotation. The resulting communication should look like this for case splitting.

\begin{Verbatim}
-> ((:elab-action :case-split 5 '((:name . "x"))) 13)
<- (:return (:ok '((:fun-defn . "pred Z = ?p_1")
                   (:fun-defn . "pred (S k) = ?p_2"))) 13)
\end{Verbatim}
Notice that the call to the editor states that we are calling the \Elab\ action
that does case splitting, and it takes an argument list, which happens
to be a singleton list that contains a pair of a tag and a string. The tag
states that the string should be handled as a variable name by the compiler.
The result from the editor returns that the action succeeded and then a list of
results.  In the result list we have two entries, each of which is a pair of a
tag and a string.  The tags in here state that the string represents a function
definition.

Now let's think of the other end of this editor action. What would the type of
such an \Elab\ action be?

\begin{Verbatim}
caseSplit : TTName -> FunClause -> TTName -> Elab (List FunClause)
\end{Verbatim}

As a first cut, we can imagine an editor action that takes the name of the function
we are performing the case split on, the function clause we are splitting,
and the variable name that should occur in the aforementioned function clause,
and will be split by the editor action. As a result, our editor action should return
a list of function clauses, what the aforementioned function clause turns into
after the split.

The types in this editor action are reflection types. But what if we wanted to write
a editor action takes an argument of a non-reflection type, such as \ty{Nat}, then
how would the compiler know how to pass the editor action the right type of arguments?
More importantly, can we check in compile time if the editor knows how to pass
arguments to the editor action in question? An editor action should only deal
with the types that can be sent from and to the editor.
In other words, we want to have a subset of types, and to check in compile time
if the types in the type signature of the editor action are all in this subset.

If we were using Haskell, we could define a type family, and only have instances
for the types we want to allow. A type family in Haskell is a type-level
function, one might think since we are dealing with dependent types we can
already write type-level functions! However Idris does not allow us to pattern
match on types, because that breaks parametricity and type erasure.\cite{universePat}
We could opt for an alternative called the universe pattern, however we should
save the user the trouble of learning the universe we define. Moreover, any
universe that we will define cannot be extended by the user. If the user later
wants to define a new type of their own and to use that in the editor action,
they should be able to do that.

The solution to our problem is to have an interface.\footnote{Haskell's type
classes and type class instances are called interfaces and implementations,
respectively. In Haskell there can only be one instance for the same type class
and the type, but in Idris for the same interface and the type, there can be
multiple implementation. You can name implementations and state the
implementation you want to use by name, when you are writing a function. For
our purposes, they are pretty much the same.}
We can define a new interface \ty{Editorable}, which only has implementations
that we know how to communicate with the editor. For the user defined types,
the user is free to give an implementation for the \ty{Editorable} interface of
that type. Then what should such an interface consist of?
The way that we communicate with the editor right now is through S-expressions,
as we described earlier. Therefore we can require our types to have two
methods, one from the type to an S-expression, and one to go from an
S-expression to the type. In other words, one to serialize the type, and one
the deserialize it. Let's call them \fn{toEditor} and \fn{fromEditor}, respectively.

\begin{Verbatim}
interface Editorable a where
  fromEditor : SExp -> Maybe a
  toEditor : a -> SExp
\end{Verbatim}

Then we would have implementations of this interface for the reflection types.

\begin{Verbatim}
err : String
err = "Primitive instance of the Editorable interface"

implementation Editorable TTName where
  fromEditor = idris_crash err
  toEditor   = idris_crash err
\end{Verbatim}

The implementations for \ty{TT}, \ty{TyDecl}, \ty{DataDefn}, \ty{FunDefn} and
\ty{FunClause} will also be the same as this.
The content that these types hold come to the compiler as a string and parsed
as a part of an abstract syntax tree. Therefore their conversions from and to
S-expressions should be handled by the compiler, because we do not have a way
to parse strings into syntax trees within Idris.

However, we are now free to define other instances of \ty{Editorable} that
might be useful, such as a \String instance and a \ty{List} instance.

\begin{Verbatim}
implementation Editorable String where
  fromEditor (StringAtom s) = Just s
  fromEditor _ = Nothing
  toEditor = StringAtom
\end{Verbatim}

If we have an S-expression primitive string, then we can convert that into
an Idris \String. If we have a different kind of S-expression, we cannot.
Conversely, if we want to convert an Idris \String\ into an S-expression, we
just make it into a string atom. Other primitive instances like \ty{Integer},
\ty{Bool} etc.\ follow the same reasoning.

\begin{Verbatim}
implementation Editorable a => Editorable (List a) where
  fromEditor (SExpList xs) = sequence (map fromEditor xs)
  fromEditor _ = Nothing
  toEditor xs = SExpList (map toEditor xs)
\end{Verbatim}

If we have an S-expression list, then we try to parse everything inside that
into S-expressions. If they all succeed, then we can parse the entire
S-expression into an Idris \ty{List}. If we do not have an S-expression list,
then we cannot parse the S-expression into an Idris \ty{List}.  When we are
converting a list into an S-expression, it is enough to convert everything in
the list to an S-expression separately, and then collect the separate
S-expressions inside a list S-expression. Other instances for the \ty{Pair},
\ty{Maybe}, \ty{Either} types follow the same reasoning.

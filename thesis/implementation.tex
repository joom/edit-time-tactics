\chapter{Implementation}\label{chap:implementation}

Before we delve into the details of implementation, we should clarify an
important distinction in regard to the terminology we will use in this chapter.

\begin{figure}[ht]
\caption{The relationship between reflection, reification, quotation,
  unquotation, elaboration and delaboration.}
\label{reflectionGraph}
\newcommand\mlnode[1]{
  \begin{minipage}{3.3cm}
    \linespread{1}\selectfont \begin{center}\small #1 \end{center}
  \end{minipage}}
\begin{tikzcd}
  \mlnode{
    Haskell terms\\ \medskip \footnotesize such as the \ty{()} term

    \dt{()}
  }
  \arrow[rrr, "\text{\small reflection}" description, bend right=20]
  &  &  &
  \mlnode{
    Haskell representation of Idris core language terms\\ \medskip \scriptsize
    such as the \ty{Term}\footnotemark term

    \texttt{\dt{P} (\dt{DCon} \dt{0} \dt{0} \dt{False}) (\dt{UN} \dt{"MkUnit"}) (\dt{P} (\dt{TCon} \dt{0} \dt{0 \dt{False}}) (\dt{UN} \dt{"Unit"}) \dt{Erased})}
  }
  \arrow[lll, "\text{\small reification}" description, bend right=20] \\
  &  &  &\\
  \mlnode{
    Idris terms\\ \medskip \footnotesize such as the \ty{()} term

    \dt{()}
  }
  \arrow[r, "\text{\small elaboration}" description, bend right=50]
  &
  \mlnode{
    Idris core terms\\ \medskip \footnotesize such as the \ty{Unit} term

    \dt{MkUnit}
  }
  \arrow[l, "\text{\small delaboration}" description, bend right=50]
  \arrow[rr, "\text{\small quotation}" description, bend right=35]
  & &
  \mlnode{
    Idris representation of the Haskell representation of Idris core language terms\\
    \medskip \scriptsize such as the \TT\ term

    \texttt{\dt{P} (\dt{DCon} \dt{0} \dt{0}) (\dt{UN} \dt{"MkUnit"})\\
    (\dt{P} (\dt{TCon} \dt{0} \dt{0}) (\dt{UN} \dt{"Unit"}) \dt{Erased})}
  }
  \arrow[ll, "\text{\small unquotation}" description, bend right=35]
  \arrow[uu, leftrightarrow, "\text{\small \emph{correspondence}}" description, dashed]
\end{tikzcd}
\end{figure}
\footnotetext{In the compiler source code in Haskell, both \ty{Term} and
  \ty{Type} are aliases for \ty{TT Name}. This should not be confused with the
  type of reflected names, \ty{TTName}, defined in Idris. In the compiler, the
  type of typed core language terms, \TT, is indexed by the type of names in
  that term. The type of names in the compiler is called \ty{Name}, therefore
  \texttt{TT Name} in the compiler is the type of core language terms with the
  usual names. We will stick with \ty{Term} and \ty{Type} in this thesis to
  avoid this confusion.}

In the previous sections, we have informally used the word ``reflection'' to
refer to the act of providing an Idris representation for a Haskell type we use
in the compiler.  That was not an incorrect usage, since moving from a Haskell
term to the Haskell representation of an Idris term is reflection as we define
above. Since this holds for any Haskell term, take a Haskell term that is
itself an internal Haskell representation of some Idris syntax.
% If we reflect that
% we can start from a Haskell term that is itself an internal Haskell
% representation of some Idris syntax.  The reflected term then is the Haskell
% representation of

Since Idris types and terms must have a Haskell representation in the compiler so that the compiler can manipulate them.
\section{Additions to the Idris standard library}\label{sec:stdlib}

\newcommand{\LR}{\texttt{Language.Reflection}}
\newcommand{\LRE}{\texttt{Language.Reflection.Elab}}
\newcommand{\LREd}{\texttt{Language.Reflection.Editor}}

Out of the types we skimmed through in \autoref{ssec:reflectedTypes}, \TT,
\Raw, and \ty{TTName} live in the \texttt{Language.Reflection} module, and
\ty{TyDecl}, \ty{DataDefn}, and \ty{FunDefn} live in \LRE. This is because
Idris only has quotation of terms, as we reviewed in \autoref{ssec:quotation},
so the definitions we will need in quotations are in \LR. The ones that are not
needed by quotation but are needed for elaborator reflection are in \LRE.

Out of the types we defined in \autoref{sec:types}, \ty{SExp} should live in
\LRE\ since \Elab\ will depend on it. However, the new interface
\Editorable\ should live in \LREd.

Remember from \autoref{code:newElabPrims} that we added two new
\Elab\ primitives to our language, namely \fn{prim\_\_fromEditor} and
\fn{prim\_\_toEditor}.
The way \Elab\ primitives work in Idris is that there is a constructor in the
\Elab\ data type for each of them. Therefore we need to add those constructors
and then define \fn{prim\_\_fromEditor} and \fn{prim\_\_toEditor} in terms of
them.

\begin{figure}[ht]
\caption{New constructors for the new \Elab\ primitives, and function definitions based on them.}
  \label{code:newElabConstructors}
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\kw{export}
\kw{data} \ty{Elab} : \ty{Type} -> \ty{Type} \kw{where}
  -- the constructors we had before
  \dt{Prim__FromEditor} : \{\bn{a} : \ty{Type}\} -> \ty{HasEditorPrim} \bn{a} -> \ty{SExp} -> \ty{Elab} \bn{a}
  \dt{Prim__ToEditor} : \{\bn{a} : \ty{Type}\} -> \ty{HasEditorPrim} \bn{a} -> \bn{a} -> \ty{Elab} \ty{SExp}

\kw{export}
\fn{prim__fromEditor} : \{\kw{auto} \bn{has} : \ty{HasEditorPrim} \bn{a}\} -> \ty{SExp} -> \ty{Elab} \bn{a}
\fn{prim__fromEditor} \{\bn{has} = \bn{x}\} \bn{sexp} = \dt{Prim__FromEditor} \bn{x} \bn{sexp}

\kw{export}
\fn{prim__toEditor} : \{\kw{auto} \bn{has} : \ty{HasEditorPrim} \bn{a}\} -> \bn{a} -> \ty{Elab} \ty{SExp}
\fn{prim__toEditor} \{\bn{has} = \bn{x}\} \bn{y} = \dt{Prim__ToEditor} \bn{x} \bn{y}
\end{Verbatim}
\end{figure}

We make the additions in \autoref{code:newElabConstructors} in \LRE.  Notice
that \kw{export} for \Elab\ does not export the constructors for the module,
and we do not want to export all the primitive actions without any limits. For
that purpose, we define \fn{prim\_\_fromEditor} and \fn{prim\_\_toEditor} that
we actually can export. Compared to the types of the constructors we defined,
types of the functions we defined are tweaked by making the \ty{HasEditorPrim}
argument automatically inferrable by proof search, which is
an accomodating feature of Idris usable via the \kw{auto} keyword.

We will inspect in \label{sec:primitiveEditorableImpl} how these new
constructors will be used in the compiler.

\section{Primitive \ty{Editorable} implementations}\label{sec:primitiveEditorableImpl}

In \autoref{ssec:primitiveEditorableDesign} we discussed why core language
types like \ty{TT}, \ty{TyDecl}, \ty{DataDefn}, \ty{FunDefn}, and
\ty{FunClause} must have primitive implementations of the
\Editorable\ interface. Recall that for each of these types, the editor can
only send a piece of code to the compiler, as a string which contains code in
the surface language, however these types are in the core language. There are
many steps in between that we are missing, such as parsing, elaboration,
delaboration and pretty printing.

Now let's see how we implemented this in the Idris compiler. Tactic evaluation
in the compiler happens in the \fn{runElabAction} defined in the compiler
source code. Inside that, there is a helper function \fn{runTacTm} that takes a
typed term corresponding to a value in the \Elab\ monad of Idris, which should
correspond to a \Elab\ primitive constructor applied to arguments, i.e. when
the \Elab\ action term is in a weak head normal form\footnote{Hereinafter referred
to as WHNF.}. Then we can check what primitive constructor we are dealing with
and behave accordingly.

\begin{figure}[ht]
\caption{The \fn{runElabAction} function in the compiler, how \Elab\ action terms are run under the hood.}
\label{code:runElabAction}
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Haskell}}, labelposition=topline]
\fn{runElabAction} :: \ty{ElabInfo} -> \ty{IState} -> \ty{FC} -> \ty{Env}
              -> \ty{Term} -> [\ty{String}] -> \ty{ElabD} \ty{Term}
\fn{runElabAction} \bn{info} \bn{ist} \bn{fc} \bn{env} \bn{tm} \bn{ns} = \kw{do} \bn{tm}' <- \fn{eval} \bn{tm}
                                         \fn{runTacTm} \bn{tm}'

  -- some helper functions ...

  \fn{runTacTm} :: \ty{Term} -> \ty{ElabD} \ty{Term}
  \fn{runTacTm} \bn{tac}@(\fn{unApply} -> (\dt{P} _ \bn{n} _, \bn{args}))
    | \bn{n} \fn{==} \fn{tacN} \dt{"Prim__Solve"}
    = \kw{do} ~[] <- \fn{tacTmArgs} \dt{0} \bn{tac} \bn{args}
          \fn{solve}
          \fn{returnUnit}
    -- other cases for other constructors
\end{Verbatim}
\end{figure}

In \autoref{code:runElabAction} we can observe how \fn{runElabAction} is
defined in the compiler.
It takes many arguments, such as informaion for the elaborator, the internal
state of the compiler at that point, the source location of the action, the
environment under which the \Elab\ term should be evaluated to a WHNF, the
term that represents the \Elab\ action term, and a namespace.  For our purposes,
we do not have to worry about all of these.

In the definition of \fn{runElabAction} we evaluate \bn{tm} to a WHNF
of the \Elab\ action, and then we check in \fn{runTacTm} which form we want run.

If we have a WHNF of the \Elab\ action, that means when we decide
that what we have is a variable term, which is a constructor, represented by
\dt{P}, or it is a series of applications to a variable term that is a
constructor. We can handle both situations with the
\texttt{\fn{unApply} :: \ty{Term} -> (\ty{Term}, [\ty{Term}])} function,
which takes a dissects multiple curried function applications into the the term
that should be a function, and the list of argument terms passed to
it.\footnote{A term that is not a function application will be treated as a
function application with no arguments passed.}

We included in \autoref{code:runElabAction} how an example \Elab\ action
term is treated by \fn{runTacTm}. For the primitive version of the \fn{solve}
action, which is represented by the \dt{Prim\_\_Solve} constructor in \Elab,
we first make sure that there are no given arguments, and then run
\texttt{\fn{solve} :: \ty{Elab'} \bn{aux} \ty{()}} in the internal elaborator
monad. If these all succeed, we return the reflected unit term back.

Now, in order to add more \Elab\ primitives, we have to do similar cases for
\dt{Prim\_\_FromEditor} and \dt{Prim\_\_ToEditor} in \fn{runTacTm}, which we
started to do in \autoref{code:runElabAction}.

\begin{figure}[ht]
\caption{Adding cases for \dt{Prim\_\_FromEditor} and \dt{Prim\_\_ToEditor} in \fn{runTacTm} in the compiler.}
\label{code:runElabAction}
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Haskell}}, labelposition=topline]
\fn{runTacTm} :: \ty{Term} -> \ty{ElabD} \ty{Term}
\fn{runTacTm} \bn{tac}@(\fn{unApply} -> (\dt{P} _ \bn{n} _, \bn{args}))
  -- other cases for other Elab primitives
  | \bn{n} \fn{==} \bn{tacN} \dt{"Prim__FromEditor"}
  = \kw{do} ~[\bn{ty}, \bn{hasEditorPrim}, \bn{arg}] <- \fn{tacTmArgs} \dt{3} \bn{tac} \bn{args}
        \bn{ty'} <- \fn{eval} \bn{ty}
        \bn{arg'} <- \fn{eval} \bn{arg}
        \kw{case} \bn{ty'} \kw{of}
          \dt{P} _ \bn{tyN} _ | \bn{tyN} \fn{==} \fn{reflm} \dt{"TT"} ->
            -- now we want to convert an S-expression to TT
          \dt{P} _ \bn{tyN} _ | \bn{tyN} \fn{==} \fn{tacN} \dt{"TyDecl"} ->
            -- now we want to convert an S-expression to TyDecl
          -- other cases for other core language types
  | \bn{n} \fn{==} \bn{tacN} \dt{"Prim__ToEditor"}
  = \kw{do} ~[\bn{ty}, \bn{hasEditorPrim}, \bn{arg}] <- \fn{tacTmArgs} \dt{3} \bn{tac} \bn{args}
        \bn{ty'} <- \fn{eval} \bn{ty}
        \bn{arg'} <- \fn{eval} \bn{arg}
        \kw{case} \bn{ty'} \kw{of}
          \dt{P} _ \bn{tyN} _ | \bn{tyN} \fn{==} \fn{reflm} \dt{"TT"} ->
            -- now we want to convert a TT into an S-expression
          \dt{P} _ \bn{tyN} _ | \bn{tyN} \fn{==} \fn{tacN} \dt{"TyDecl"} ->
            -- now we want to convert a TyDecl into an S-expression
          -- other cases for other core language types
\end{Verbatim}
\end{figure}

Observe that we left most parts in here blank, let's zoom in to the \TT\ cases
  of \dt{Prim\_\_FromEditor} and \dt{Prim\_\_toEditor}.

For the \TT\ case of \dt{Prim\_\_FromEditor}, we have to do the following steps:
\begin{enumerate}
  \item We have an Idris term \bn{arg'} representing the S-expression passed to
    the \dt{Prim\_\_FromEditor}, we have to reify this and get a Haskell term
    that is the S-expression.
  \item Parse the surface syntax.
  \item Elaborate that into the core language
  \item Reflect that to Raw in the core language
  \item Typecheck the reflected term from Raw to TT
  \item Evaluate and return the TT
\end{enumerate}

Let's see in \autoref{code:ttFromEditor} how this can be implemented in the compiler.

\begin{figure}[ht]
\caption{The \TT\ case of \dt{Prim\_\_FromEditor}.}
\label{code:ttFromEditor}
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Haskell}}, labelposition=topline]
\dt{P} _ \bn{tyN} _ | \bn{tyN} \fn{==} \fn{reflm} \dt{"TT"} ->
\end{Verbatim}
\end{figure}


\section{Extensions to the Idris IDE mode}\label{sec:idemode}

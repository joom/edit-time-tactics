\chapter{Introduction} \label{chap:introduction}

The rising popularity of statically typed functional languages led to
the concept of ``type-driven development'' (hereinafter referred to as TDD),
which is a style of development that revolves around the types of missing parts in
programs. The expressions we have not written yet, or ones we do not know
how to write, can be left as holes in our program, and the program still
compiles, with a warning that there are incomplete parts.
A hole is kind of expression, and since these languages are
statically typed, those holes have types; the parts
we have already written dictate what the types of the remaining parts should
be. These types can guide us when we try to fill the holes to complete the program.
In other words, TDD lets us write our programs incrementally and top-down. This
not only lets us type-check our program at every step, it also gives us clever
hints about the following steps, based on the types and the local contexts.
% Especially as dependent types gradually sneak into mainstream languages, like
% they already have to Haskell\cite{eisenberg} and Scala\cite{scalaDep} now, we
% predict that TDD will only get more popular.
This idea was originally born in the world of proof assistants and then it was
borrowed by more practical functional languages.
Interactive editing based on types has been used in proof assistants for a long
time; the LCF system\cite{lcf} and its successors HOL and
Isabelle\cite{isabelle} have allowed users to prove theorems
incrementally. Users type in commands called ``tactics'' that update the proof state by
changing the goal, or by creating subgoals.
Even though tactics generate a Curry-Howard style proof term at the end, these
proof assistants have focused on changing the proof term indirectly.
Inspired by these systems, others arose which
provide a new interface and type theory that focuses on
changing the proof terms directly by incrementally building them
up\footnote{Changing the proof term indirectly with tactics is also called
backward reasoning, and incrementally building up the proof term is called
forward reasoning.}. One of the earliest such proof assistants was the ALF proof
editor\cite{ALF}, and the idea was developed further by Epigram\cite{epigram}
and Agda\cite{agda}.
The ideas that are brewed in these proof assistants continue to inspire more
mainstream functional languages.

The traditional programming depended on saving a file and trying to compile (or
run) with every edit. This has changed with the advancement of integrated
development environments (IDEs), programs that have certain functionalities
such as code completion, syntax checking, displaying compiler error messages on
their corresponding lines, searching in documentation etc.
These features are convenient, but they are different from TDD.
While IDEs can also use types to assist the user, they do not direct the
entire development process around types per se.
TDD is not a program, it is merely a style of programming in which
the development process takes the form of a conversation between the
type-checker/compiler and the user's editor/IDE.  However, this requires
certain changes to the compiler, such as being able to type-check incomplete
expressions and definitions.\cite{tdd}

The kind of change that is important for this work is the editor
interaction mode (or the IDE mode, as it is called in Idris\cite{idris}) that
lets the editor talk to the compiler\footnote{To avoid any confusion,
we should mention that there are two different parts of an editor interaction
mode. The first is a plugin to the editor, often written in the script language
of the editor, such as Emacs Lisp or VimL. The second part is a separate
program that does the heavy lifting of the editing features that work with the
language itself.  \texttt{ghc-mod} in Haskell and \texttt{agda-mode} in Agda would
be perfect examples for the second part. We can call these parts the frontend
and backend of the editor interaction mode, respectively.  When we talk about
the language the editor interaction mode is implemented, we mean the language
used in the backend, because the language used in the frontend depends on the
editor.}.
There are various existing examples of compilers and editors that do this sort
of interaction:
Proof General\cite{pg} and CoqIDE for Coq\cite{coq},
the Emacs mode\cite{agdamode} for Agda,
the Emacs mode\cite{idrismode} for Idris,
jEdit\cite{isabellejedit} for Isabelle,
and the editor mode of Lean\cite{lean}.\footnote{Haskell's typed holes in GHC
are exciting, but they do not enjoy the seamless editor interaction yet that
Agda and Idris do.}
Idris has a special place among these proving languages since it tries to
prioritize general purpose programming. Among the mainstream languages
that have mature IDEs, Idris still has an unusual standing since it also is a
proof assistant.\cite{idrisfaq}
This unique position of Idris provides motivation for editor features on par
with mature IDEs for other languages, as well as the TDD-style development
workflow via editor actions.
Our work strives to bring the long-standing traditions of proof assistants and
IDEs closer together, by introducing a feature called ``edit-time tactics''.
The word ``edit-time'' is a wordplay on the terms ``compile time'' and ``run
time'', and it means that we run the tactics when were are still in the editor,
in order to use them to help us define new editor actions.
The area of bringing IDE features to proof assistants is not new\cite{ctcoq,
developingReuse, realTheoremProvers, toolSupport}, but it has been focusing
on their usefulness as proof tools, not necessarily how they can help
mainstream programmers. In contrast, we take tactics from proof assistants
and see how they can help type-driven developers.

Before we proceed to describe our work,
it is imperative to understand what exactly an editor action is.
Editor actions are commands in the editor that make a meaningful
change in your code, or one that gives you some information about your
code. For example, if you are trying to define a function to compute the height
of a binary tree\footnote{The \texttt{\IdrisKeyword{\%name}} directive here tells
Idris how to generate new names for trees. This is not necessary.}, you can
just start by writing the type for the function.

\vspace{1em}
\includegraphics[scale=0.6]{edit1}

Note that initially we only declared the type of the function, and nothing
else. To get an initial incomplete definition, we can run the editor action
``Add initial match clause to type declaration'', while the cursor is on the
type declaration.

\vspace{1em}
\includegraphics[scale=0.6]{edit2}

Now we have a definition for \fn{height} that takes one argument \bn{t1}, and
returns \hole{height\_rhs}. This is clearly incomplete; we want to change
the return value based on what \bn{t1} is. So the next step would be to inspect
what values \bn{t1} can take. We can place the cursor on \bn{t1} and then run the
editor action ``Case split pattern variable''.

\vspace{1em}
\includegraphics[scale=0.6]{edit3}

Now we have two holes that we have to complete, namely \hole{height\_rhs1} and
\hole{height\_rhs2}. When the cursor is on one of the holes, we can run the
editor action ``Display type'' and see what type of expression should replace
the hole, and what names are in the local context, i.e. are available to use
when writing that expression.

\vspace{1em}
\includegraphics[scale=0.6]{edit4}

Finishing this function from here is trivial, so we will not proceed further.
However, this example should show how much editor actions can shape your
programming experience.

\section{Motivation}

Now that we are familiar with what an editor action is, we can describe problem
our project solves. Editor actions we reviewed above are features embedded
in the compiler. If you want to define a new action, the only way possible is
to change the compiler source code and build your own version of the compiler,
and then edit the source code of your editor mode to use that feature you
added. This is clearly far from ideal; no one should have to fork a compiler
just to add a custom editor action. Maintaining a compiler fork and
navigating through the compiler source code are usually not in the skill sets
of most users.
Another drawback is that users would have to learn Haskell, and recompile the
entire Idris system every time they want to define a custom editor action.

Therefore we want to give users a way to write custom editor actions. Our
solution for this is to make use of elaborator reflection\cite{elabref} in
Idris, which is a metaprogramming machinery that allows users to automate the
construction of proofs and programs, by reflecting the elaborator
monad\cite{idris} in the Idris compiler. Christiansen and Brady showed that
this mechanism is powerful enough to replace the old tactic
language\cite{elabref} that existed in the previous versions of Idris, which is
now deprecated in favor of elaborator reflection.

Elaborator reflection adds a primitive monad \Elab\ to Idris itself, in which
type-checking and normalizing terms, looking up types and definitions of
functions are monadic actions\footnote{These monadic actions are still called
tactics, especially if they change the goal queue or the local context, hence the
title of this thesis. Note that whenever we use the word ``tactic'' in the
context of Idris, we exclusively refer to the monadic \Elab\ actions, not the
old tactic language.}.
This thesis argues that these actions provide a nice interface with which users
can define their custom editor actions. This has the following advantages:

\begin{itemize}
\item Implementations of the Idris editor actions mentioned above are
built-into the compiler and they are written in Haskell. Our work will allow
us to rewrite them in Idris as \Elab\ actions. This way we can remove these
parts from the compiler and move them into an Idris library.
\item Abilities of the editor interaction mode is extended from the
current built-in features to anything that can be done with tactics.
\item Defining editor actions with a monadic interface allows us to
compose them easily. For instance, if we had case-splitting as an \Elab\
action, we could define a tactic to case-split on many arguments at the same time.
\end{itemize}

The ability to run tactics as editor actions has a consequence
that we have not explored much in this thesis.
Idris programs are usually meant to be executed, unlike Coq or
Agda programs, which are usually only meant to be type checked.\footnote{Of
  course there are backends for these languages, such as the OCaml
  backend for Coq and the Haskell backend for Agda.}
This means Idris programs will be compiled more often than Agda or Coq in the long run,
since not much code is added to proofs after its completion, but practical programs tend to change in time. Therefore, minimizing compile time is more of a priority for Idris.
Idris tactics generate proof terms in compile time, but the
compilation can take a long time for complex tactics\footnote{Similar problems
are observed in Coq. For example, theorems that use the famous \texttt{omega}
tactic that decides Presburger arithmetic take a long time to compile, and it
usually generates a huge proof term.},
not to mention that the implementation of elaborator
reflection in Idris has significant performance issues.\cite{leanmeta}
Yet we still want to utilize complex tactics to generate proofs or terms.
Using edit-time tactics, one would run a tactic once from the editor, generate
the proof term and serialize and send that to the editor and put it back in the
file.
If we think of the differences between the traditions of writing the proof
terms directly and writing tactics, the former more common in Agda and Idris
and the latter in Coq and Isabelle, this work will constitute a one way bridge
between the two, by making use of the elaborator reflection to create proof
terms in the editor in a smarter and quicker way.

The problem with that approach is that the generated proof terms can be (and
often are) gigantic and hideous, especially if generating a minimal proof term
is not a priority for the tactic we are using.
If there was a generic mechanism to simplify and minimize the generated proof
terms, and even write them in a way that makes use of dependent pattern
matching, then this could have been a more usable consequence of this work.
Ideally, we would want the artifact we are handing in to the reader of our
proofs to look just like what it would be if we had not used this system.
We leave that for future work.  However, even without proof simplification,
this still could be a last resort solution to long compile times for tactics.

\section{Contributions}

To achieve the advantages listed above, we make the following specific
contributions in this thesis:
\begin{itemize}
\item We extend the primitive \Elab\ monad with the necessary primitive monadic
actions that make writing an editor action with elaborator reflection possible.
(\autoref{sec:stdlib})
\item We define an Idris interface (or type class in Haskell terminology)
called \ty{Editorable} for serializing and deserializing Idris expressions.
For the reflected type that represents the core language terms of Idris,
implementations of this interface are primitives. (\autoref{sec:types})
\item We add an interval map in which keys are intervals of source code
positions (pair of line and column numbers) and values are local contexts at
those positions. This allows us to inspect what local variables are available to
use anywhere in the source code. (\autoref{sec:extendIState})
\item The current proof search mechanism in Idris is not particularly advanced.
We write an alternative proof search tactic called Hezarfen, a full-blown
theorem prover for intuitionistic propositional logic, and then we show how
to use this on holes when we are in the editor.  (\autoref{sec:hezarfen})
\item We define a add clause tactic that can be run from the editor, which can
replace the hard-coded add clause editor action.  (\autoref{sec:addClause})
\end{itemize}

Some of the features we implemented in this thesis have already made their way to
the Idris compiler, and the rest also will once they are reviewed by the
other Idris contributors.

\TODO{Hopefully edit-time tactics will look just the same to the "end user". to
the tactic writer, it looks like the "examples in action" section for tactic
writers. We have three different users: editor action users, simple action
writers, and ones that want to define their own editorable instances. It would
be ideal to have one working example in the introduction section to give a
taste of what we actually did!}




Now that we have gotten a taste of edit-time tactics, let's go over the basics
of the Idris programming language and its metaprogramming machinery in
\autoref{chap:background}.
We will discuss the design of the edit-time tactics feature in
\autoref{chap:design} and their implementation in
\autoref{chap:implementation}.

Before we move on the other chapters, it might be helpful to take a brief look
at the typographic conventions we use in this thesis: When we have code
excerpts, we will use a monospace font.  Keywords will be written in \kw{black
boldface}, types will be \ty{blue}, constant and function names will be
\fn{green}, bound variables will be \bn{purple}, metavariables and holes
will be \texttt{\IdrisMetavar{cyan}}, and comments will be in
\cm{dark gray}.\footnote{We are following the color conventions in Conor McBride's
Epigram paper\cite{epigram} and David Christiansen's
dissertation\cite{davidphd}.} We will have code excerpts in different
programming languages such as Idris, Haskell, and Emacs Lisp in this thesis,
hence we will always explicitly state what language the code is in, but we will
use the same syntax highlighting for all of them.

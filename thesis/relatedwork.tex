\chapter{Related work} \label{chap:relatedwork}

\section{In Haskell}

Template Haskell \cite{th} is the main metaprogramming mechanism in Haskell.
It is similar to elaborator reflection in the sense that metaprograms are
defined in a monad called \ty{Q}, which allows metaprograms to create fresh
names and look up definitions.
Template Haskell metaprograms generate expressions and definitions, which are
among the capabilities of the \Elab\ monad in Idris.
However, there are significant differences;
quotations in Template Haskell return values in the \ty{Q} monad, and Template
Haskell does not try to reflect the elaboration infrastructure of
Haskell.\footnote{However, Haskell metaprogramming using the GHC core language
has been discussed in the GHC developers mail list, with credit to Idris:
\url{http://mail.haskell.org/pipermail/ghc-devs/2015-November/010402.html}}
Neither does it hold an internal proof state that can be changed by monadic
actions, nor it does try to provide an alternative way to implement tactics in
Haskell.\footnote{That being said, Siva Somayyajula has a rudimentary
implementation a tactic monad in Haskell based on the \ty{Q} monad:
\url{http://github.com/ssomayyajula/elab}}

Brian McKenna worked on expanding the definitions generated by Template Haskell
to source code, which then is pretty printed and put back into the source code
in Emacs using YASnippet.\footnote{His tweet with screenshots can be found at
\url{http://twitter.com/puffnfresh/status/935274097642057728} and the project
that enables this feature can be found at
\url{http://hackage.haskell.org/package/th-pprint}.}

On the IDE feature side of things, Alan Zimmerman and Matthew Pickering
developed \texttt{ghc-exactprint}\footnote{It can be found here:
\url{http://hackage.haskell.org/package/ghc-exactprint}}, which is a library
that helps IDE and tooling development by providing a way to refactor Haskell
programs without changing a part of the program unintentionally. As they put
it, their library respects ``the identity refactoring'', which is non-trivial
if your system allows many different kinds of
transformations.\cite{ghc-exactprint-blog}
There is also the Haskell IDE Engine project that aims integrate many Haskell
tools based on the GHC API to the editor workflow, by providing a backend for
editor modes.\footnote{The project can be found here:
\url{http://github.com/haskell/haskell-ide-engine}, and Alan Zimmerman's talk
at the Haskell Implementors' Workshop 2017 can be found here:
\url{http://youtu.be/-pjQcG94CxM}}

\section{In Agda}

There is a line of work on bringing more automated theorem proving,
proof automation and tactics, or metaprogramming to Agda.
Lindblad and Benke (2006) introduced a term search algorithm called
Agsy, a proof search mechanism that aims to save users' time by automating
parts of the proof that are straightforward but tedious to write.\cite{agsy}
Agda has a derivative of this mechanism implemented as a part of its compiler.
Kokke and Swierstra (2015) used the old reflection system of Agda to define a
new proof search mechanism in Agda itself.\cite{autoinagda}
The Hezarfen tactic we discussed in \autoref{sec:hezarfen} is not as advanced
as their \fn{auto} function, yet in their paper, they discussed a feature
similar to edit-time tactics as future work:

\begin{quote}
  ``In the future, it may be interesting to explore how to integrate proof
  automation using the reflection mechanism better with Agda's IDE. For
  instance, we could create an IDE feature which replaces a call to
  \fn{auto} with the proof terms that it generates. As a result, reloading
  the file would no longer need to recompute the proof terms.''\cite{autoinagda}
\end{quote}

In this thesis, we generalized their suggestion to all tactics, and specified
how the editor/IDE and the compiler should communicate with each other
in order to successfully call a tactic with inputs of the correct types.

There is also work on ``proof by reflection'' in Agda, which is different from our
usage of the word ``reflection'' so far.

\begin{quote}\label{quote:reflection}
``Reflection is an overloaded word in this context, since in programming language
  technology reflection is the capability of converting some piece of concrete
  code into an abstract syntax tree object that can be manipulated in the same
  system. Reflection in the proof technical sense is the method of mechanically
  constructing a proof of a theorem by inspecting its shape.''\cite{reflInAgda}
\end{quote}

We have been concerned with the first meaning of ``reflection'' in this thesis,
however the work on the second meaning of this word is still relevant to proof
automation, and their ideas can be reused in our edit-time tactics. Work by van
der Walt and Swierstra showed compelling examples of proof by reflection in
Agda, such as a proof mechanism for boolean tautologies.\cite{pfByReflAgda}

\section{In Coq}

Coq has a metaprogramming mechanism called
\texttt{template-coq}\footnote{It can be found here:
\url{https://github.com/Template-Coq/template-coq}} that is based on
Malecha's term reification. \cite{malecha-phd}. Recently a typed
version of this system is also introduced. \cite{typed-template-coq}
However, we are not aware of any work on using template metaprograms in Coq to
write new features for the editor.

Aside from this, there is a large body of work on proof automation, proof
engineering and tactic languages in Coq.  Coq's original tactic language is
Ltac\cite{ltac}, which is separate from its Coq's term language Gallina.
However, alternatives to Ltac have been developed, such as Mtac\cite{mtac} and
MetaCoq\cite{metacoq}.  Especially Mtac\cite{mtac}, which is a tactic language
for Coq that facilitates custom proof search by providing a monadic interface,
has inspired further research in the area, including Idris' elaborator
reflection.\cite{elabref}

Chlipala's \emph{Certified Programming with Dependent Types}\cite{cpdt} has
emerged as the canonical introductory textbook for proof engineering; it
explains the basics of tactic programming and even delves into proof search and
proof by reflection. Note that we use the word reflection in the proof
technical sense, \hyperref[quote:reflection]{as mentioned in the quote above}.

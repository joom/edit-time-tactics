\section{Applications} \label{sec:applications}

\subsection{Regular Expression Simplification}

\TODO{should I?}
One of the most promising benefits of our work is that it allows
domain-specific custom editor actions.

\subsection{Reimplementing the Built-In ``Add Clause'' Action}\label{sec:addClause}

Idris's Emacs mode supports a built-in editor action called ``Add initial match
clause to type declaration.'' When the cursor is on the type signature of a
function that does not have any clauses, the user can run this editor action
and get an initial clause for the function.

In this section we implement an editor action for top-level type declarations
without implicit arguments or interface constraints, using custom editor actions.
The Idris code necessary for it is in \autoref{code:addClause}.

\begin{figure}[ht]
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\fn{collectTypes} : \ty{TT} -> (\ty{List} \ty{TT}, \ty{TT})
\fn{collectTypes} (\dt{Bind} _ (\dt{Pi} \bn{ty} _) \bn{t}) =
  \kw{let} \dt{(}\bn{xs}\dt{,} \bn{t'}\dt{)} = \fn{collectTypes} \bn{t} \kw{in}
  (\bn{ty} \fn{::} \bn{xs}, \bn{t'})
\fn{collectTypes} \bn{t} = \dt{([]}, \bn{t})

\kw{%editor}
\fn{addClause} : \ty{TTName} -> \ty{Elab} (\ty{FunClause} \ty{TT})
\fn{addClause} \bn{n} =
  \kw{do} \dt{(}_\dt{,} _\dt{,} \bn{ty}\dt{)} <- \fn{lookupTyExact} \bn{n}
     \bn{env} <- \fn{getEnv}
     \bn{ty'} <- \fn{normalise} \bn{env} \bn{ty}
     \kw{let} \dt{(}\bn{argTys}\dt{,} \bn{retTy}\dt{)} = \fn{collectTypes} \bn{ty'}
     \bn{argNames} <- \fn{traverse} (\fn{const} \fn{fresh}) \bn{argTys}
     \kw{let} \bn{lhsUntyped} =
       \fn{foldl} \dt{RApp} (\dt{Var} \bn{n}) (\fn{map} \dt{Var} \bn{argNames})
     \dt{(}\bn{lhsTyped}\dt{,} _\dt{)} <- \fn{check} \bn{env} \bn{lhsUntyped}
     \bn{holeName} <- \fn{fresh}
     \kw{let} \bn{rhs} = \dt{Bind} \bn{holeName} (\dt{GHole} \bn{retTy}) (\dt{V} \dt{0})
     \fn{pure} (\bn{MkFunClause} \bn{lhsTyped} \bn{rhs})
\end{Verbatim}
\caption{Implementation of the editor action for ``add clause''.}
\label{code:addClause}
\end{figure}

The \fn{collectTypes} function takes a type and dissects it into components, and returns
a pair of the list of inputs and the output type. For instance,
\mt{\fn{collectTypes} \kw{\`{}(}\ty{Nat} -> \ty{Bool} -> \ty{String}\kw{)}}
will return \mt{(\dt{[}\kw{\`{}(}\ty{Nat}\kw{)},
\kw{\`{}(}\ty{Bool}\kw{)}\dt{]},\kw{\`{}(}\ty{String}\kw{)})}.

The \fn{addClause} action only takes one input, which is the name of the function
it will add an initial clause for.
Using this name, it looks up the type of that function,
normalizes the type, and gets its components
using \fn{collectTypes}.
It names the list of input types \bn{argTys}, and the output type \bn{retTy}
For each of member of \bn{argTys}, it generates a new name using
\fn{fresh}. It later uses these names and makes them
into variable terms, using \dt{Var}, and creates a function application using
all of these names. This application is supposed to represent the left-hand
side in the final definition. The right-hand side is a hole term that has the
type \bn{retTy}. This concludes the type declaration term.

The Emacs Lisp code necessary to run \fn{addClause} as a custom editor action
is the same as the existing add-clause editor action, except the part that
Emacs sends a message to the compiler; the message now should refer to
\fn{addClause} instead of the built-in add-clause editor action.

To use this editor action, the user would write a type signature.

\begin{Verbatim}
\fn{example} : (\bn{name} : \ty{String}) -> (\bn{age} : \ty{Nat}) -> \ty{IO} \ty{()}
\end{Verbatim}

If the user puts the cursor on the name \fn{example} and executes the Emacs
Lisp code they will get the following result:

\begin{Verbatim}
\fn{example} : (\bn{name} : \ty{String}) -> (\bn{age} : \ty{Nat}) -> \ty{IO} \ty{()}
\fn{example} \bn{a} \bn{b} = \hole{c}
\end{Verbatim}

This concludes the rudimentary replacement the the existing add-clause section.
For simplicity purposes, we have not covered the type signatures with implicit
arguments or interface constraints. One can write a custom editor action to
handle those cases as well.

\subsection{A Theorem Prover for Intuitionistic Propositional Logic}\label{sec:hezarfen}

In this section, we describe the procedure Hezarfen\footnote{The name is
  pronounced ``has are fan'', and it means
    polymath in Turkish. Source code is available at
    \url{http://github.com/joom/hezarfen}.}, which can decide intuitionistic
propositional logic theorems, similar to Coq's \texttt{tauto} tactic.
This procedure will be based on Dyckhoff's LJT~\cite{ljt} and its Haskell
implementation Djinn~\cite{djinn}, which generates Haskell expressions
for a given type.
Djinn is a standalone program that takes commands
interactively, and when it generates an expression it prints it on the screen.
Instead, Hezarfen is a library that provides an \Elab\ action
that can be used as a tactic in proofs, and a custom editor action to be run
when the built-in proof search mechanism does not suffice.

The prover consists of a couple mutually recursive functions that try to break
the goal type down into components, recursively finds terms that satisfy the
components, and then glues them together based on the initial matched goal
type.

Later in the prover there is also a term simplifier, similar to Haskell's
pointfree style
converter.\footnote{\url{http://hackage.haskell.org/package/pointfree}} It does
eta reduction, removes unused \kw{let} bindings, and applies similar
simplification steps repeatedly.
However, this simplifier is tailored for Hezarfen's proof terms; it is not
general purpose.  The necessity of further work on a general purpose one is
discussed in \autoref{sssec:simplification}.

\begin{figure}[h]
\begin{Verbatim}
\fn{comm} : (\bn{a}, \bn{b} : \ty{Type}) -> \ty{Either} \bn{a} \bn{b} -> \ty{Either} \bn{b} \bn{a}
\fn{comm} = \hole{comm_impl}
\end{Verbatim}
  \vspace{1em}
\begin{Verbatim}
\fn{comm} : (\bn{a}, \bn{b} : \ty{Type}) -> \ty{Either} \bn{a} \bn{b} -> \ty{Either} \bn{b} \bn{a}
\fn{comm} = \fn{either} \dt{Right} \dt{Left}
\end{Verbatim}
\caption{Before and after invoking Hezarfen}
  \label{fig:hezarfen-example}
\end{figure}

Figure~\ref{fig:hezarfen-example} displays the results of
executing this editor action on a hole.
Hezarfen finds a term that satisfies that the type of the hole.
Observe that the type of \fn{comm} corresponds to the logical proposition
$(a \lor b) \to (b \lor a)$, and by finding a term of the type Hezarfen proves
that proposition.

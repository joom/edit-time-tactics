\section{Applications} \label{sec:applications}

\subsection{Regular Expression Simplification}

\TODO{should I?}
\TODO{Yes, but make it a lower priority than the other things. We have space, and it's a cool demo!}

\subsection{Reimplementing the Built-In ``Add Clause'' Action}\label{sec:addClause}

Idris's editor modes support a built-in editor action called ``Add initial match
clause to type declaration.'' When the cursor is on the type signature of a
function that does not have any clauses, the user can run this editor action
and get an initial pattern clause for the function.
For instance, invoking the command on the declaration
\begin{Verbatim}
\fn{copy} : (\bn{n} : \ty{Nat}) -> \bn{a} -> \ty{Vect} \bn{n} \bn{a}
\end{Verbatim}
results in the clause
\begin{Verbatim}
\fn{copy} \bn{n} \bn{x} = \hole{copy_rhs}
\end{Verbatim}
which has a bound variable for each explicit argument in \fn{copy}'s type.

There is no longer any need to implement this feature in Haskell as
part of the compiler. This section describes the implementation of an
editor action in Idris itself that generates initial clauses for top-level
type declarations without implicit arguments or interface
constraints. A version that handles these additional features is
longer, but involves no additional concepts. The complete Idris code that
implements this editor action can be seen in \autoref{code:addClause}.

\begin{figure}[ht]
\begin{Verbatim}[framesep=2mm, label=\footnotesize{\normalfont{Idris}}, labelposition=topline]
\fn{collectTypes} : \ty{TT} -> (\ty{List} \ty{TT}, \ty{TT})
\fn{collectTypes} (\dt{Bind} _ (\dt{Pi} \bn{ty} _) \bn{t}) =
  \kw{let} (\bn{xs}, \bn{t'}) = \fn{collectTypes} \bn{t} \kw{in}
  (\bn{ty} \fn{::} \bn{xs}, \bn{t'})
\fn{collectTypes} \bn{t} = \dt{([]}, \bn{t})

\kw{%editor}
\fn{addClause} : \ty{TTName} -> \ty{Elab} (\ty{FunClause} \ty{TT})
\fn{addClause} \bn{n} =
  \kw{do} (_, _, \bn{ty}) <- \fn{lookupTyExact} \bn{n}
     \bn{ty'} <- \fn{normalise} !\fn{getEnv} \bn{ty}
     \kw{let} (\bn{argTys}, \bn{retTy}) = \fn{collectTypes} \bn{ty'}
     \bn{argNames} <- \fn{traverse} (\fn{const} \fn{fresh}) \bn{argTys}
     \kw{let} \bn{lhsUntyped} =
       \fn{foldl} \dt{RApp} (\dt{Var} \bn{n}) (\fn{map} \dt{Var} \bn{argNames})
     \bn{env} <- \fn{getEnv}
     (\bn{lhsTyped}, _) <- \fn{check} \bn{env} \bn{lhsUntyped}
     \bn{holeName} <- \fn{fresh}
     \kw{let} \bn{rhs} = \dt{Bind} \bn{holeName} (\dt{GHole} \bn{retTy}) (\dt{V} \dt{0})
     \fn{pure} (\bn{MkFunClause} \bn{lhsTyped} \bn{rhs})
\end{Verbatim}
\caption{Implementation of the editor action for ``add clause''.}
\label{code:addClause}
\end{figure}

The \fn{collectTypes} function takes a type and dissects it into components, and returns
a pair of the list of inputs and the output type. For instance,
\mt{\fn{collectTypes} \kw{\`{}(}\ty{Nat} -> \ty{Bool} -> \ty{String}\kw{)}}
returns \mt{\dt{(}\dt{[}\kw{\`{}(}\ty{Nat}\kw{)}\dt{,}
\kw{\`{}(}\ty{Bool}\kw{)}\dt{]}\dt{,}\kw{\`{}(}\ty{String}\kw{)}\dt{)}}.

The \fn{addClause} action only takes one input, which is the name of
the function declaration for which an initial clause has been
requested.  Using this name, it looks up the type of that function,
normalizes the type, and gets its components using \fn{collectTypes}.
The list of input types is named \bn{argTys}, and the output type is
named \bn{retTy}. For each of member of \bn{argTys}, it generates a
new user-accessible name using \fn{fresh}. A more featureful
implementation would attempt to preserve names from the type
signature, only generating fresh names when the user had not provided
a name or in the presence of shadowing.

A pattern match clause consists of a left-hand side, which is an
application of the function being defined to either constructors or
pattern variables, and a right-hand side, which is the expression that
results when the pattern on the left-hand side matches.  Having found
names for each pattern variable, the left hand side of the initial
clause is constructed by applying the function being defined, using
\dt{RApp}.  The \dt{Var} constructor injects names into terms.  The
right hand side of the initial clause should consist only of a hole
for the user to fill in, indicated by the \dt{GHole} term constructor.
Because Idris holes are binding forms, the de~Bruijn index \dt{0}
refers back to this new hole.


The Emacs Lisp code necessary to run \fn{addClause} as a custom editor
action is the almost identical to the existing add-clause editor
action.  The only difference is that the call to the primitive
add-clause editor action in the IDE protocol is replaced by a call to
\fn{addClause}.

Using this editor action on the declaration
\begin{Verbatim}
\fn{example} : (\bn{name} : \ty{String}) -> (\bn{age} : \ty{Nat}) -> \ty{IO} \ty{()}
\end{Verbatim}
results in an initial match clause
\begin{Verbatim}
\fn{example} \bn{a} \bn{b} = \hole{c}
\end{Verbatim}
which was just as expected. However, this new version is much more
readily extensible by users.

\subsection{A Theorem Prover for Intuitionistic Propositional Logic}\label{sec:hezarfen}

In this section, we describe the procedure Hezarfen\footnote{The name is
  pronounced ``has are fan'', and it means
    polymath in Turkish. Source code is available at
    \url{http://github.com/joom/hezarfen}.}, which can decide intuitionistic
propositional logic theorems, similar to Coq's \texttt{tauto} tactic.
This procedure will be based on Dyckhoff's LJT~\cite{ljt} and its Haskell
implementation Djinn~\cite{djinn}, which generates Haskell expressions
for a given type.
Djinn is a standalone program that takes commands
interactively, and when it generates an expression it prints it on the screen.
Instead, Hezarfen is a library that provides an \Elab\ action
that can be used as a tactic in proofs, and a custom editor action to be run
when the built-in proof search mechanism does not suffice.

The prover consists of a couple mutually recursive functions that try to break
the goal type down into components, recursively finds terms that satisfy the
components, and then glues them together based on the initial matched goal
type.

Later in the prover there is also a term simplifier, similar to Haskell's
pointfree style
converter.\footnote{\url{http://hackage.haskell.org/package/pointfree}} It does
eta reduction, removes unused \kw{let} bindings, and applies similar
simplification steps repeatedly.
However, this simplifier is tailored for Hezarfen's proof terms; it is not
general purpose.  The necessity of further work on a general purpose one is
discussed in \autoref{sssec:simplification}.

\begin{figure}[h]
\begin{Verbatim}
\fn{comm} : (\bn{a}, \bn{b} : \ty{Type}) -> \ty{Either} \bn{a} \bn{b} -> \ty{Either} \bn{b} \bn{a}
\fn{comm} = \hole{comm_impl}
\end{Verbatim}
  \vspace{1em}
\begin{Verbatim}
\fn{comm} : (\bn{a}, \bn{b} : \ty{Type}) -> \ty{Either} \bn{a} \bn{b} -> \ty{Either} \bn{b} \bn{a}
\fn{comm} = \fn{either} \dt{Right} \dt{Left}
\end{Verbatim}
\caption{Before and after invoking Hezarfen}
  \label{fig:hezarfen-example}
\end{figure}

Figure~\ref{fig:hezarfen-example} displays the results of
executing this editor action on a hole.
Hezarfen finds a term that satisfies that the type of the hole.
Observe that the type of \fn{comm} corresponds to the logical proposition
$(a \lor b) \to (b \lor a)$, and by finding a term of the type Hezarfen proves
that proposition.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "source"
%%% End:

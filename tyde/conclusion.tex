\section{Conclusion}\label{sec:conclusion}

\subsection{Future Work}

We consider the following topics worth pursuing as they will amplify the effects
of our work.

\subsubsection{Proof Simplification}
\label{sssec:simplification}

\citet{elabref} showed that elaborator reflection can be used as a tactic
language for theorem proving. It is possible to use \Elab{} tactics to define
custom editor actions and reuse existing proof automation efforts directly from
the editor.

\Elab{} tactics generate a proof term during elaboration, but the artifact is
only a call to the tactic, which affords users to ignore the proof terms
generated by the tactics. However gigantic or hideous the proof terms are,
readers of the code will only see that the tactics satisfy the goal and they
will not see the proof term itself. Many proof automation procedures such as
Coq's \mt{omega}~\cite{omega} enjoy this leeway.
However, when using \Elab{} tactics to
define custom editor actions, the artifact is directly a proof term. Hence,
brevity and readability are desirable qualities in the proof terms generated by
those tactics.
Requiring all tactic authors to abide by these qualities is burdensome, and it
hampers reuse of existing tactics written without regard to those qualities.
If there was a generic mechanism to simplify and minimize
generated proof terms, and even write them in a way that makes use of dependent
pattern matching, then this could be a more usable consequence of our work.
Ideally, the artifact handed in to the reader of the user's proofs should
similar to what it would be without using custom editor actions based on proof
automation.  We leave that for future work.

% \subsubsection{Writing an editor action frontend in Idris}

% We explained in \autoref{sec:introduction} that this paper focuses on writing
% the backend of an editor action in Idris, and that we still had to write some
% Emacs Lisp (if we are using Emacs). However, Idris supports many different
% code generation targets~\cite{idriscodegen} seamlessly.

% For example, since compiling to JavaScript is built-in, we can use JavaScript
% code generation to write the editor interaction frontend for Visual Studio Code
% and Atom.

% There are also experimental projects on compiling Idris to Emacs
% Lisp\footnote{Steven Shaw's work on compiling Idris to Emacs Lisp:
% \url{http://github.com/steshaw/idris-elisp}} and VimL
% (Vimscript)\footnote{Oskar Wickstr\"om and Soham Chowdhury's work on
% compiling Idris to VimL:
% \url{https://github.com/owickstrom/idris-vimscript}}. These projects are not
% mature enough yet, but we believe they have the potential to inspire different
% applications of metaprogramming, especially if the Idris modes of these editors
% are written in Idris via their respective code generation targets.

\subsubsection{Universe Encoding}
\label{sssec:universeEncoding}

Subsection~\ref{ssec:typechecking} described how the compiler should check if all
components of an editor action type have an instance of the \Editorable{} type
class. However, it is not necessary to implement this as a part of type checking,
it would suffice to encode it as a universe type~\cite{genericDep} and a
function from that universe to \ty{Type}.
The universe type would serve as a a wrapper around the arrow type that checks
if the type on the left of the arrow has an \Editorable{} instance.
\autoref{code:universe} shows a possible universe type and
defines a function to map the members of a universe to Idris types.

\begin{figure}[H]
\begin{Verbatim}
\kw{data} \ty{Act} : \ty{Type} \kw{where}
  \dt{Done} : (\bn{a} : \ty{Type}) -> \ty{Editorable} \bn{a} => \ty{Act}
  \dt{Arg} : (\bn{a} : \ty{Type}) -> \ty{Editorable} \bn{a} => \ty{Act} -> \ty{Act}

\fn{actTy} : \ty{Act} -> \ty{Type}
\fn{actTy} (\dt{Done} \bn{a}) = \ty{Elab} \bn{a}
\fn{actTy} (\dt{Arg} \bn{a} \bn{e}) = \bn{a} -> \fn{actTy} \bn{e}
\end{Verbatim}
\caption{Universe encoding of types feasible to be treated as editor actions.}
\label{code:universe}
\end{figure}

\autoref{code:universe-example} shows how the type of the \fn{easy} editor
action from \autoref{fig:motivating-example} would change with this encoding.

\begin{figure}[H]
\begin{Verbatim}
\fn{easy} : \fn{actTy} (\dt{Arg} \ty{TTName} (\dt{Done} \TT))
\fn{easy} \bn{n} = \cm{\{- elided, same as before -\}}
\end{Verbatim}
\caption{\fn{easy}  rewritten as a universe encoded editor action.}
\label{code:universe-example}
\end{figure}

Observe that \mt{\fn{actTy} (\dt{Arg} \ty{TTName} (\dt{Done} \TT))} evaluates
to \mt{\ty{TTName} -> \Elab{} \TT}, therefore the definition of \fn{easy} does
not have to change.

\TODO{How does this allow dependent editor actions?}

\subsection{Final Words}

In this paper, we extended the capabilities of the editor interaction mode of
Idris by allowing users to define new editor actions in Idris itself. We did
so through a metaprogramming technique that was introduced to Idris recently by
Christiansen and Brady~\cite{elabref}.

Editors communicate with the compiler via S-expressions, so we gave users the
power to dictate how a value of a given Idris type should exactly be
communicated; through the \ty{Editorable} interface users are now able to
define how a received S-expression should be parsed by the compiler, and how
the compiler should send the result as an S-expression. To achieve this, we
reflected the \ty{SExp} type to Idris, and extended elaborator reflection
by adding new \Elab\ primitives, with which we defined the \ty{Editorable}
implementations for Idris types representing the Haskell representation of
Idris core language terms.

Using this feature, we showed a simple \fn{toy} example, and then the
\fn{addClause} example that can replace an existing built-in editor action,
and Hezarfen, which is meant to be a better proof search mechanism than the
built-in one. We believe there is potential to replace even more of the
built-in editor actions with custom editor actions written in Idris, such as
case-splitting and lifting a hole into a lemma. We can also add new general
editor actions such as renaming a binder, renaming a function within a file,
pruning unused arguments in a function, etc.

We also believe that as more decision procedures are coded up in Idris,
custom editor actions based on proof automation can become a more popular
feature. Especially library and DSL authors can ship custom editor actions for
their package, which would allow library users to write code more easily with
that library or DSL.

Hopefully our work will bring dependently-typed languages one step closer to the
state-of-the-art IDEs, and even give them an edge by allowing the reuse of the
existing metaprogramming mechanisms and tactic engineering efforts to write
editor actions.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "source"
%%% End:

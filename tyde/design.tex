\section{Design}\label{sec:design}

When the user invokes an editor action, the editor has to tell the Idris
compiler what to run. Since the editor and the compiler run in different processes,
for each interaction the editor has to send a message to the compiler,
and the compiler has to send a message back to the editor.
These messages are formatted in Lisp-style \sexp{}s \cite{mccarthy}.

The \Elab{} monad in Idris primitively keeps track of a special kind of state
involving a term satisfying a goal and new declarations generated as
side effects during elaboration.
These elaborator reflection scripts have the type \mbox{\ty{Elab ()}}. Since the
desired metaprogramming effects are captured by the special state, there is
nothing interesting to return.

However, when \Elab{} scripts are used as editor actions, they should be able
to return any kind of data depending on what the editor action needs to send
back to the editor.
If an editor action needs to send back an expression to the editor, then the
action should have the return type \mbox{\ty{Elab TT}}, where \ty{TT} is the type of
terms in Idris's core language.
Similarly if a user needs to define an action that creates a function definition,
then the action that does that should have the return type \mbox{\ty{Elab FunDefn}},
where \ty{FunDefn} is the type of function definitions in the core language.
Alternatively, for a simple editor action that only needs to send a number back
to the editor, the return type should be \mbox{\ty{Elab Nat}}, where \ty{Nat} is the
type of natural numbers.

\subsection{The \Editorable{} type class and its instances}
\label{ssec:editorable}

The problem with allowing any return type within \Elab{} is that the compiler
does not know how to represent values of arbitrary types as \sexp{}s.
In order to give users the power to define how values of a given types should
be represented as \sexp{}s, we define a type class called
\Editorable{},\footnote{Haskell's type classes and their instances are
respectively called \mbox{\emph{interface}s} and \mbox{\emph{implementation}s}
in Idris. In this paper, we will use the Haskell terminology in prose, but we
will use the correct keywords in code excerpts.}
which outlines what the compiler needs to know about a type to be able to serialize and deserialize between values of that type and \sexp{}s.

\begin{figure}[H]
\begin{Verbatim}
\kw{interface} \ty{Editorable} \bn{a} \kw{where}
  \fn{fromEditor} : \ty{SExp} -> \ty{Elab} \bn{a}
  \fn{toEditor} : \bn{a} -> \ty{Elab} \ty{SExp}
\end{Verbatim}
\caption{Definition of the \Editorable{} type class.}
\label{code:editorable}
\end{figure}

Whenever users want to inform the compiler about the \sexp{}
representation of values of a type, they have to define an instance of the
\Editorable{} type class. Later when a user runs an editor action from an
editor, the \Editorable{} instances are used for communication via
\sexp{}s.

\subsubsection{\Editorable{} instances written in Idris}

For instance, values of primitive types such as \ty{String} can be represented
as atomic \sexp{}s.

\begin{figure}[H]
\begin{Verbatim}
\kw{implementation} \ty{Editorable} \ty{String} \kw{where}
  \fn{fromEditor} (\dt{StringAtom} \bn{s}) = \fn{pure} \bn{s}
  \fn{fromEditor} \bn{x} = \fn{fail} \dt{[}\cm{\{- elided -\}}\dt{]}
  \fn{toEditor} \bn{x} = \fn{pure} (\dt{StringAtom} \bn{x})
\end{Verbatim}
\caption{\ty{String} instance of the \ty{Editorable} type class.}
\label{code:editorableString}
\end{figure}

For values of types such as \mbox{\ty{Maybe String}},
\mt{\dt{Just "abc"}} can be represented as \mt{(\dt{:Just "abc"})}, a list
\sexp{} with a symbol atom as the first element and then the \sexp{}
representation of a string, and \dt{Nothing} can be represented as
\dt{:Nothing}. This can be generalized into all instantiations of
\ty{Maybe} as follows:

\begin{figure}[H]
\begin{Verbatim}
\kw{implementation} \ty{Editorable} \bn{a}
            => \ty{Editorable} (\ty{Maybe} \bn{a}) \kw{where}
  \fn{fromEditor} (\dt{SExpList [SymbolAtom "Nothing"]}) =
    \fn{pure} \dt{Nothing}
  \fn{fromEditor} (\dt{SExpList [SymbolAtom "Just"}, \bn{x}\dt{]}) =
    \kw{do} \bn{x}' <- \fn{fromEditor} \bn{x}
       \fn{pure} (\dt{Just} \bn{x}')
  \fn{fromEditor} \bn{x} = \fn{fail} \dt{[}\cm{\{- elided -\}}\dt{]}
  \fn{toEditor} (\dt{Just} \bn{x}) =
    \kw{do} \bn{x'} <- \fn{toEditor} \bn{x}
       \fn{pure} (\dt{SExpList} \dt{[}\dt{SymbolAtom} \dt{"Just"}, \bn{x'}\dt{]})
  \fn{toEditor} \dt{Nothing} =
    \fn{pure} (\dt{SExpList [SymbolAtom "Nothing"]})
\end{Verbatim}
\label{code:editorableMaybe}
\caption{\ty{Maybe} instance of the \ty{Editorable} type class.}
\end{figure}

The idea that is introduced here can be used to define an \Editorable{}
instance for any data type that has exported constructors. Constructors that do
not take any argument are represented as symbol atoms, and the ones that do
take arguments are represented as a list \sexp{}, in which the first element is
a symbol atom and the other elements represent the arguments that the
constructor takes. We will call this the \emph{constructor-based \sexp{}
representation} of a type.

For function types like \mbox{\ty{Nat -> Nat}}, however, the \sexp{}
representation is not as clear. The problems in
defining a \ty{Show} instance for function types apply here as well \cite{showfunction},
hence disqualifing arbitrary function types from being \sexp{} representable
works around those issues. In other words, there is no \ty{Editorable} instance
for arbitrary functions.

It is also possible to give an \Editorable{} instance for the type of Idris
names, \ty{TTName}, which appeared in \autoref{fig:motivating-example}, in
Idris itself.  For instance, the Idris name \fn{Prelude.Bool.not}, which has the
data type representation \mt{\dt{NS "not" ["Bool"}, \dt{"Prelude"]}}, is
represented by a string atom \sexp{}, namely \dt{"Prelude.Bool.not"}. All Idris
names are represented by string atoms, the reason for which will be clear in
the next paragraph. We elide the \Editorable{} instance of \ty{TTName} since
it mostly consists of string and list manipulation that can be confusing
without further familiarity with the constructors of \ty{TTName}.

\subsubsection{Primitive \Editorable{} instances}

The \sexp{} representations of Idris's core language types, such as \TT{} and
\TyDecl{}, are the most challenging ones. These types mirror the internal
representation of Idris's core language, but they are merely algebraic data
types defined in Idris, which means one has the option to choose the
constructor-based representation to define an \Editorable{} instance.
Nevertheless, that representation would not be helpful to modify the code in
the editor, since the constructor representation would just be a syntax tree of
the core language representation of an expression. Yet users work with the
concrete syntax, i.e.\ the actual text file that represents the code, when they
are in the editor; when they use editor actions they expect to see concrete
syntax put back into the file. Therefore, the editor should send and receive
concrete syntax, not the constructor-based representation of \TT{}, which is the type
representing the abstract syntax tree of Idris's core language, or not the
high-level syntax tree of Idris, or anything else.

On the other hand, if the compiler receives concrete syntax and needs to run \Elab{}
actions on that, there are many missing steps in between, most important of
which is elaboration from a high-level language to the core language.
Similarly, if the compiler needs to send back concrete syntax after
running \Elab{} actions, then it needs to reverse all those steps.
In other words, there is a colossal gap between concrete syntax and the core
language that needs to be bridged and this task can be delegated to the
\Editorable{} type class.

When the \sexp{} received by the compiler is a string atom that is a
piece of Idris code, i.e.\ concrete syntax, \fn{fromEditor} should parse that
string into a high-level language term, and then elaborate that into a core
language term. Only after that can the compiler run the \Elab\ editor action.
Similarly, when the \Elab\ action finishes, \fn{toEditor} should convert core
language terms into the high-level language terms, which is called
\emph{delaboration} in Idris. Then the compiler should invoke the pretty
printer to get concrete syntax that represents that term. The resulting string
can be sent back from the compiler to the editor as a string atom \sexp{}.

Bridging this gap requires an \Editorable{} instance for \TT{} that does parsing,
elaboration, delaboration and pretty printing. Defining such an instance in
Idris itself is not possible with the current implementation of \Elab{}, since
the elaborator monad in Idris does not expose these features.
The way to work around this is to define primitive instances of \Editorable{}
for the core language types like \TT{}, \TyDecl{} and \FunDefn{}.
Hard-coding the \Editorable{} instances of \ty{TT}, \ty{TyDecl},
\ty{DataDefn}, \ty{FunDefn}, and \ty{FunClause} into the compiler
allows \emph{direct reflection}~\cite{barzilayphd} by making use
of the already existing compiler implementations of the steps listed above.

To achieve this, the existing \Elab{} monad needs to be extended with
primitives that go through the steps mentioned above.  One \Elab{} primitive
for \fn{fromEditor} and one for \fn{toEditor} would suffice; polymorphic
primitives constrained by a \ty{Type}-indexed family would provide a principled
way to manage the primitive instances of \Editorable{}.

\begin{figure}[H]
\begin{Verbatim}
\kw{data} \ty{HasPrim} : \ty{Type} -> \ty{Type} \kw{where}
  \dt{HasTT}        : \ty{HasPrim} \ty{TT}
  \dt{HasTyDecl}    : \ty{HasPrim} \ty{TyDecl}
  \dt{HasDataDefn}  : \ty{HasPrim} \ty{DataDefn}
  \dt{HasFunDefn}   : \ty{HasPrim} (\ty{FunDefn} \ty{TT})
  \dt{HasFunClause} : \ty{HasPrim} (\ty{FunClause} \ty{TT})
\end{Verbatim}
\caption{Definition of the \ty{HasPrim} predicate in Idris.}
\end{figure}

\ty{HasPrim} is used to define new \Elab{} primitives:

\begin{figure}[H]
\begin{Verbatim}
\fn{prim__fromEditor} : \ty{HasPrim} \bn{a} -> \ty{SExp} -> \ty{Elab} \bn{a}
\fn{prim__toEditor} : \ty{HasPrim} \bn{a} -> \bn{a} -> \ty{Elab} \ty{SExp}
\end{Verbatim}
  \caption{The new \Elab\ primitives.}
\label{code:newElabPrims}
\end{figure}

Using these two primitives, the \Editorable{} instances for the core language
types all look alike:

\begin{figure}[H]
\begin{Verbatim}
\kw{implementation} \ty{Editorable} \ty{TT} \kw{where}
  \fn{fromEditor} \bn{x} = \fn{prim__fromEditor} \dt{HasTT} \bn{x}
  \fn{toEditor} \bn{x} = \fn{prim__toEditor} \dt{HasTT} \bn{x}
\end{Verbatim}
  \caption{An \Editorable{} instance depending on the new primitives.}
\end{figure}

\subsection{How the compiler uses \Editorable{} for communication}
\label{ssec:communication}

In figures \ref{fig:motivating-example} and \ref{fig:motivating-example-exec},
we have presented a simple editor action \fn{easy}, its supporting Emacs Lisp code,
and examples that show how they work. When the user puts the cursor on
\hole{ex1\_impl} and invokes \fn{idris-easy} in their Emacs session, Emacs sends a message to the compiler that specifies that it wants to run \fn{easy}, and provides a list of arguments, \mt{(\fn{list} \dt{"ex1\_impl"})}, which is a singleton list containing a string atom.
\fn{easy} only takes a single argument of the type \ty{TTName}. \TODO{this is hard to write without shifting to the tutorial style}


\subsection{Using \Editorable{} in type-checking}
\label{ssec:typechecking}

The motivation behind the \ty{Editorable} type class is twofold:
\begin{enumerate}
\item to use the \fn{fromEditor} and \fn{toEditor} definitions to serialize
  and deserialize data before and after an \Elab{} action is run.
\item to check whether a given \Elab{} action is suitable to be used as an
  editor action.
\end{enumerate}

The first motivation is already covered by the previous subsections.
\TODO{explain "components of a type" and how they all have \Editorable{} instances}

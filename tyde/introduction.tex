\section{Introduction} \label{sec:introduction}

Rich type systems give programmers a way to express their intentions
as types, statically ruling out many incorrect programs. But rich
types are useful for much more than preventing mistakes: the static
information provided by informative types can be used by interactive
programming environments to guide the construction of programs,
automating away tedious details and freeing the programmer to
concentrate on the parts of their problem that require creativity.

Type-driven interactive programming environments necessarily embody
their developers' assumptions about how programmers will use
them. These assumptions, however, can never hold for all members of a
diverse community of programmers working on a variety of
problems. Rather than continuing to pound nails with screwdrivers,
extensible languages demand extensible programming environments.
Unfortunately, interactive features are presently part of the
compiler, and facility in dependently typed programming does not imply
the ability to extend the implementation of dependently typed
languages. Maintaining these changes over time as the underlying
language is improved is an additional practical difficulty.

The Idris elaborator~\citep{idris} is built from a collection of
powerful, general-purpose tools for constructing programs in a simpler
core type theory. The high-level Idris language is extensible using
\emph{elaborator reflection}~\citep{davidphd, elabref}, which directly
exposes these tools to Idris programs, so that Idris can be extended
in itself. Concretely, elaborator reflection extends Idris with a
primitive monad \Elab{}. Just as values in \IO{} describe effectful
programs to be executed by the run-time system, \Elab{} actions
describe effectful programs to be run during type checking and
elaboration. Effects in \Elab{} include checking the type of an
expression, looking up the definition of a datatype or program,
failing with an informative error message, and constructing new
expressions that may or may not contain holes to be filled in by
future metaprograms. Elaborator reflection has since been adopted in
Agda and Lean; the Lean developers have made substantial improvements
to its practicality~\citep{leanmeta, agdachangelogTC}.


We have extended Idris's implementation of elaborator reflection with
new primitives that enable it to be used to construct \emph{editor
  actions}. These editor actions have access to the full power of
\Elab{}, but instead of running in the course of elaboration, they are
manually invoked by programmers to modify already-elaborated programs.
With these new primitives, it becomes possible to write
domain-specific editor actions for embedded domain-specfic
languages~\citep{dsel} and to replace parts of the compiler with
customizable library code written in Idris. Even more importantly,
users who were previously stuck with whatever the developers provided
are now empowered to make not only their language, but also their
environment, their own.

\subsection*{Contributions}

We make the following contributions in this paper:
\begin{itemize}
\item We explore the additional features that are necessary to use
  elaborator reflection to implement editor actions~(\autoref{sec:design}).
\item We describe a concrete realization of this design, and the
  communication protocol that allows it to work in multiple
  interactive environments~(\autoref{sec:types}).
\item We describe a non-trivial editor action that invokes Hezarfen, a
  theorem prover for intuitionistic propositional logic based on
  Dyckhoff's LJT~\cite{ljt}, and we show how to use it to
  interactively fill the holes found in incomplete
  programs~(\autoref{sec:hezarfen}).
\item We demonstrate the replacement of part of Idris's implementation
  with Idris library code by demonstrating an editor action that
  constructs an initial implementation of a function, given its
  signature~(\autoref{sec:addClause}).
\end{itemize}


\subsection{Motivating example}

\TODO{Explain the following example. I didn't just want to do the unit case
because then that seems too easy. Doing Refl and unit together is still
somewhat readable (?) and it's more interesting than just doing unit.}

\begin{Verbatim}
\kw{%editor}
\fn{trivial} : \ty{TTName} -> \ty{Elab} \ty{TT}
\fn{trivial} \bn{n} =
  \kw{do} (_, _, \bn{ty}) <- \fn{lookupTyExact} \bn{n}
     \kw{case} \bn{ty} \kw{of}
       \kw{`(}\ty{Unit}\kw{)} =>
         \fn{pure} \kw{`(}\dt{MkUnit}\kw{)}
       \kw{`(}(\dt{=}) \{A=\kw{\textasciitilde}\bn{a}\} \{B=\kw{\textasciitilde}\bn{b}\} \kw{\textasciitilde}\bn{x} \kw{\textasciitilde}\bn{y}\kw{)} =>
         \kw{if} \bn{a} \fn{==} \bn{b} \fn{&&} \bn{x} \fn{==} \bn{y}
         \kw{then} \fn{pure} \kw{`(}\dt{Refl} \{A=\kw{\textasciitilde}\bn{a}\} \{x=\kw{\textasciitilde}\bn{x}\}\kw{)}
         \kw{else} \fn{fail} \dt{[TextPart "Not equal"]}
       _ =>
         \fn{fail} \dt{[TextPart "Cannot solve"]}


\end{Verbatim}

\TODO{Explain the following examples step by step, maybe with screenshots}

\begin{Verbatim}
\fn{ex1} : \ty{Unit}
\fn{ex1} = \dt{()}

\fn{ex2} : (\fn{not} \dt{False}) = \dt{True}
\fn{ex2} = \dt{Refl}
\end{Verbatim}



% Some of the features we implemented in this paper have already made their way to
% the Idris compiler, and the rest also will once they are reviewed by the
% other Idris contributors.

We envision three different audiences for this paper:
\begin{enumerate}[(1)]
\item Idris programmers who use editor actions in their editor, who will now
  have access to more editor actions. For them, reading the applications of
edit-time tactics in \autoref{sec:applications} would be the most helpful.
\item Advanced Idris programmers who want to write simple editor actions, using
  the common Idris types and reflected types. More advanced Idris programmers
    may want to write more complex editor actions that involve data types
    that they define.
    They may want to read \autoref{sec:design} in order to understand the
    design of our feature and what should be taken into account when defining
    such data types.
\item Compiler developers and contributors for Idris and other
  dependently-typed languages.  They may want to read
    \autoref{sec:implementation} in order to observe what we needed to change
    in the compiler, and how they can add this feature to a different language.
\end{enumerate}

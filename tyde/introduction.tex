\section{Introduction} \label{sec:introduction}

Rich type systems give programmers a way to express their intentions
as types, statically ruling out many incorrect programs. But rich
types are useful for much more than preventing mistakes: the
information provided by informative types can be used by programming
tools to guide program construction, automating away tedious details
and freeing programmers to concentrate on the parts of their
problem that require human creativity.

Type-driven programming environments are necessarily built according
to language developers' assumptions about how programmers will use
them. These assumptions, however, can never hold for all members of a
diverse community working on a variety of problems. Unfortunately, the
interactive features of Idris and Agda are presently built in to their
respective compilers, and skill in dependently typed programming does
not imply the ability to extend the implementation of dependently
typed languages and maintain those extensions so that they continue to
work as compilers are improved.

The Idris elaborator~\citep{idris} translates programs written in
Idris into a much smaller core type theory. The elaborator is written
in Haskell, making use of an elaboration monad to track the
complicated state that is involved. The high-level Idris language is
extensible using \emph{elaborator reflection}~\citep{davidphd,
  elabref}, which directly exposes the elaboration monad to Idris
programs, so that Idris can be extended in itself. Concretely,
elaborator reflection extends Idris with a primitive monad
\Elab{}. Just as values in \IO{} describe effectful programs to be
executed by the run-time system, \Elab{} actions describe effectful
programs to be run during elaboration.
\todo{insert ref to lean paper elsewhere}

We have extended Idris's implementation of elaborator reflection with
new primitives that enable it to be used to construct \emph{editor
  actions}. These editor actions have access to the full power of
\Elab{}, but instead of running in the course of elaboration, they are
manually invoked by programmers to modify already-elaborated programs.
With these new primitives, it becomes possible to write
domain-specific editor actions for embedded domain-specfic
languages~\citep{dsel} and to replace parts of the compiler with
customizable library code written in Idris. Even more importantly,
users who were previously stuck with whatever the developers provided
are now empowered to make not only their language, but also their
environment, their own.

\subsection*{Contributions}

We make the following contributions in this paper:\todo{Shorten to fit on page 1}
\begin{itemize}
\item We explore the features that are necessary to use
  elaborator reflection to implement editor actions.
\item We describe a concrete realization of this design, and the
  communication protocol that allows it to work in multiple
  interactive environments.
\item We describe a non-trivial editor action that invokes a
  theorem prover for intuitionistic propositional logic to
  interactively fill a hole in an incomplete
  program.
\item We demonstrate that editor actions written in Idris are
  sufficently powerful to replace parts of implementation by
  reimplementing a feature that constructs an initial implementation
  of a function, based on its signature.
\end{itemize}


\subsection{Motivating example}

\TODO{Explain the following example. I didn't just want to do the unit case
because then that seems too easy. Doing Refl and unit together is still
somewhat readable (?) and it's more interesting than just doing unit.}

\begin{Verbatim}
\kw{%editor}
\fn{trivial} : \ty{TTName} -> \ty{Elab} \ty{TT}
\fn{trivial} \bn{n} =
  \kw{do} (_, _, \bn{ty}) <- \fn{lookupTyExact} \bn{n}
     \kw{case} \bn{ty} \kw{of}
       \kw{`(}\ty{Unit}\kw{)} =>
         \fn{pure} \kw{`(}\dt{MkUnit}\kw{)}
       \kw{`(}(\dt{=}) \{A=\kw{\textasciitilde}\bn{a}\} \{B=\kw{\textasciitilde}\bn{b}\} \kw{\textasciitilde}\bn{x} \kw{\textasciitilde}\bn{y}\kw{)} =>
         \kw{if} \bn{a} \fn{==} \bn{b} \fn{&&} \bn{x} \fn{==} \bn{y}
           \kw{then} \fn{pure} \kw{`(}\dt{Refl} \{A=\kw{\textasciitilde}\bn{a}\} \{x=\kw{\textasciitilde}\bn{x}\}\kw{)}
           \kw{else} \fn{fail} \dt{[TextPart "Not equal"]}
       _ =>
         \fn{fail} \dt{[TextPart "Cannot solve"]}


\end{Verbatim}

\TODO{Explain the following examples step by step, maybe with screenshots}

\begin{Verbatim}
\fn{ex1} : \ty{Unit}
\fn{ex1} = \dt{()}

\fn{ex2} : (\fn{not} \dt{False}) = \dt{True}
\fn{ex2} = \dt{Refl}
\end{Verbatim}



% Some of the features we implemented in this paper have already made their way to
% the Idris compiler, and the rest also will once they are reviewed by the
% other Idris contributors.

We envision three different audiences for this paper:
\begin{enumerate}[(1)]
\item Idris programmers who use editor actions in their editor, who will now
  have access to more editor actions. For them, reading the applications of
edit-time tactics in \autoref{sec:applications} would be the most helpful.
\item Advanced Idris programmers who want to write simple editor actions, using
  the common Idris types and reflected types. More advanced Idris programmers
    may want to write more complex editor actions that involve data types
    that they define.
    They may want to read \autoref{sec:design} in order to understand the
    design of our feature and what should be taken into account when defining
    such data types.
\item Compiler developers and contributors for Idris and other
  dependently-typed languages.  They may want to read
    \autoref{sec:implementation} in order to observe what we needed to change
    in the compiler, and how they can add this feature to a different language.
\end{enumerate}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "source"
%%% End:

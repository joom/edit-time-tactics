\section{Related work} \label{sec:relatedwork}

\subsection{In Haskell}

Template Haskell~\cite{th} is the main metaprogramming mechanism in Haskell.
It is similar to elaborator reflection in the sense that metaprograms are
defined in a monad called \ty{Q}, which allows metaprograms to create fresh
names and look up definitions.
Template Haskell metaprograms generate expressions and definitions, which are
among the capabilities of the \Elab\ monad in Idris.
However, there are significant differences;
quotations in Template Haskell return values in the \ty{Q} monad, and Template
Haskell does not try to reflect the elaboration infrastructure of
Haskell.
Neither does it hold an internal proof state that can be changed by monadic
actions, nor it does try to provide an alternative way to implement tactics in
Haskell.\footnote{That being said, Siva Somayyajula has a rudimentary
implementation a tactic monad in Haskell based on the \ty{Q} monad:
\url{http://github.com/ssomayyajula/elab}}

Brian McKenna worked on expanding the definitions generated by Template Haskell
to source code, which then is pretty printed and put back into the source code
in Emacs using YASnippet.\footnote{His tweet with screenshots can be found at
\url{http://twitter.com/puffnfresh/status/935274097642057728} and the project
that enables this feature can be found at
\url{http://hackage.haskell.org/package/th-pprint}.}

% On the IDE feature side, Alan Zimmerman and Matthew Pickering
% developed \texttt{ghc-exactprint}\footnote{\url{http://hackage.haskell.org/package/ghc-exactprint}}, which is a library
% that helps IDE and tooling development by providing a way to automatically
% refactor Haskell programs without changing a part of the program
% unintentionally. As they put it, their library respects ``the identity
% refactoring'', which is non-trivial if your system allows many different kinds
% of transformations~\cite{ghc-exactprint-blog}.
% There is also the Haskell IDE
% Engine\footnote{\url{http://github.com/haskell/haskell-ide-engine}} project
% that aims to integrate many Haskell tools based on the GHC API to the editor
% workflow, by providing a backend for editor modes.

\subsection{In Agda}

There is a line of work on bringing more automated theorem proving,
proof automation and tactics, or metaprogramming to Agda.
\citet{agsy} introduced a term search algorithm called
Agsy, a proof search mechanism that aims to save users' time by automating
parts of the proof that are straightforward but tedious to write.
Agda has a derivative of this mechanism implemented as a part of its compiler.
\citet{autoinagda} used the Agda's prior reflection system to define a
new proof search mechanism in Agda itself.
The Hezarfen tactic we discussed in \autoref{sec:hezarfen} is not as advanced
as their \fn{auto} function, yet in their paper, they suggested an IDE feature
that replaces a call to their \fn{auto} with the proof terms it generates.
In this paper, we generalized their suggestion to all tactics, and specified
how the editor/IDE and the compiler should communicate with each other
in order to successfully call a tactic with inputs of the correct types.

\subsection{In Coq}

Coq has a metaprogramming mechanism called
\texttt{template-coq}\footnote{\url{https://github.com/Template-Coq/template-coq}} that is based on
Malecha's term reification~\cite{malecha-phd}. Recently a typed
version of this system is also introduced~\cite{typed-template-coq}.
However, we are not aware of any work on using template metaprograms in Coq to
write new features for the editor.

% Aside from this, there is a large body of work on proof automation, proof
% engineering and tactic languages in Coq.  Coq's original tactic language is
% Ltac~\cite{ltac}, which is separate from Coq's term language Gallina.
% However, alternatives to Ltac have been developed, such as Mtac~\cite{mtac} and
% MetaCoq~\cite{metacoq}.  Especially Mtac, which is a tactic language
% for Coq that facilitates custom proof search by providing a monadic interface,
% has inspired further research in the area, including Idris' elaborator
% reflection~\cite{elabref}.

\TODO{Talk about CoqIDE, Proof General, company-coq. I removed them from the intro, so maybe they should go here?}

\subsection{In Lean}

Lean~\cite{lean}, which has a tactic metaprogramming system~\cite{leanmeta}
similar to Idris' elaborator reflection, also allows running tactics in
edit-time, and it does not require writing any code for the editor mode
frontend.
In comparison to the edit-time tactics mechanism presented in our work, Lean's
system is very restrictive. It only allows editor action that run on holes, but
our system allows any kind of editor action as long as the user writes the
necessary glue code in the editor mode language. We already showed in
\autoref{code:elispToy}, what the glue code to fill a hole would look like in
Emacs Lisp. Another downside of Lean's system is that editor actions can only
have a single type, as opposed to our system, which allows any kind of
\Elab\ action as long as the components of the a type all have an
\Editorable\ implementation. Our system lets users write more expressive custom
editor actions.

\subsection{Other Languages}

Not every new language is conceived of as primarily a mapping from the
set of strings to the disjoint union of machine code and error
messages, with its users and tooling as an afterthought. Some are
designed from the start with a customizable interactive environment in
mind. This tradition dates back to early work on Lisp, particularly
the Lisp machines and Interlisp-D~\citep{LispHist}, as well as
Smalltalk~\citep{Goldberg1984SmalltalkEnv}. These environments are
highly customizable, but they do not allow users to continue to use
their preferred editors. Idris now occupies a space between the total
freedom of Smalltalk and a language such as Haskell for which editor
support is an afterthought.

Racket is a language that focuses on the paradigm of
\emph{language-oriented programming}~\citep{racketManifesto}, in which
problems are solved by first constructing the most appropriate
language to solve them. One part of this process is extensible,
metaprogrammable tooling, especially the DrRacket~\cite{revenge}
IDE. For instance, \citet{feltey2016languages} demonstrate a
surprisingly concise Java-like language, including refactoring tools.
It is certainly possible to implement dependently typed languages in
the Racket ecosystem: both Cur~\cite{cur} and
Pie~\cite{theLittleTyper} already exist, and the latter includes a
simple editor action system that is presently extensible only in
Racket but could support other languages as well.

Structured editors are an alternative means of interacting with a
programming language.  Alfa is a structural proof editor~\cite{alfa},
descended from an earlier system called Alf~\citep{ALF, ALFthesis}.
These structure editors are not, however, customizable using programs
written in their type theories. Likewise, while
Epigram~\citep{epigram} supported type-driven structured editing, it
was not extensible in itself. The ongoing Hazel
project~\cite{hazelnut,hazelEditor} employs the tools of programming
language theory to describe interactions with a type-aware structured
editor; however, they have not yet reflected this language of
interactions back into their object language.

% They also coined the term ``edit-time'' to
% mean when the user is writing a program in the editor, and suggested
% ``edit-time tactics'' as future work, by which they
% meant a separate language in which users can define editor actions, and a
% library of predefined editor actions that the users can compose.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "source"
%%% End:

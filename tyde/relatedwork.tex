\section{Related work} \label{sec:relatedwork}

\subsection{In Haskell}

Template Haskell~\cite{th} is the main metaprogramming mechanism in Haskell.
It is similar to elaborator reflection in the sense that metaprograms are
defined in a monad called \ty{Q}, which allows metaprograms to create fresh
names and look up definitions.
Template Haskell metaprograms generate expressions and definitions, which are
among the capabilities of the \Elab\ monad in Idris.
However, there are significant differences;
quotations in Template Haskell return values in the \ty{Q} monad, and Template
Haskell does not try to reflect the elaboration infrastructure of
Haskell.\footnote{However, Haskell metaprogramming using the GHC core language
has been discussed in the GHC developers mail list, with credit to Idris:
\url{http://mail.haskell.org/pipermail/ghc-devs/2015-November/010402.html}}
Neither does it hold an internal proof state that can be changed by monadic
actions, nor it does try to provide an alternative way to implement tactics in
Haskell.\footnote{That being said, Siva Somayyajula has a rudimentary
implementation a tactic monad in Haskell based on the \ty{Q} monad:
\url{http://github.com/ssomayyajula/elab}}

Brian McKenna worked on expanding the definitions generated by Template Haskell
to source code, which then is pretty printed and put back into the source code
in Emacs using YASnippet.\footnote{His tweet with screenshots can be found at
\url{http://twitter.com/puffnfresh/status/935274097642057728} and the project
that enables this feature can be found at
\url{http://hackage.haskell.org/package/th-pprint}.}

% On the IDE feature side, Alan Zimmerman and Matthew Pickering
% developed \texttt{ghc-exactprint}\footnote{\url{http://hackage.haskell.org/package/ghc-exactprint}}, which is a library
% that helps IDE and tooling development by providing a way to automatically
% refactor Haskell programs without changing a part of the program
% unintentionally. As they put it, their library respects ``the identity
% refactoring'', which is non-trivial if your system allows many different kinds
% of transformations~\cite{ghc-exactprint-blog}.
% There is also the Haskell IDE
% Engine\footnote{\url{http://github.com/haskell/haskell-ide-engine}} project
% that aims to integrate many Haskell tools based on the GHC API to the editor
% workflow, by providing a backend for editor modes.

\subsection{In Agda}

There is a line of work on bringing more automated theorem proving,
proof automation and tactics, or metaprogramming to Agda.
\citet{agsy} introduced a term search algorithm called
Agsy, a proof search mechanism that aims to save users' time by automating
parts of the proof that are straightforward but tedious to write.
Agda has a derivative of this mechanism implemented as a part of its compiler.
\citet{autoinagda} used the Agda's prior reflection system to define a
new proof search mechanism in Agda itself.
The Hezarfen tactic we discussed in \autoref{sec:hezarfen} is not as advanced
as their \fn{auto} function, yet in their paper, they suggested an IDE feature
that replaces a call to their \fn{auto} with the proof terms it generates.
In this paper, we generalized their suggestion to all tactics, and specified
how the editor/IDE and the compiler should communicate with each other
in order to successfully call a tactic with inputs of the correct types.

\subsection{In Coq}

Coq has a metaprogramming mechanism called
\texttt{template-coq}\footnote{\url{https://github.com/Template-Coq/template-coq}} that is based on
Malecha's term reification~\cite{malecha-phd}. Recently a typed
version of this system is also introduced~\cite{typed-template-coq}.
However, we are not aware of any work on using template metaprograms in Coq to
write new features for the editor.

% Aside from this, there is a large body of work on proof automation, proof
% engineering and tactic languages in Coq.  Coq's original tactic language is
% Ltac~\cite{ltac}, which is separate from Coq's term language Gallina.
% However, alternatives to Ltac have been developed, such as Mtac~\cite{mtac} and
% MetaCoq~\cite{metacoq}.  Especially Mtac, which is a tactic language
% for Coq that facilitates custom proof search by providing a monadic interface,
% has inspired further research in the area, including Idris' elaborator
% reflection~\cite{elabref}.

\TODO{Talk about CoqIDE, Proof General, company-coq. I removed them from the intro, so maybe they should go here?}

\subsection{In Lean}

Lean~\cite{lean}, which has a tactic metaprogramming system~\cite{leanmeta}
similar to Idris' elaborator reflection, also allows running tactics in
edit-time, and it does not require writing any code for the editor mode
frontend.
In comparison to the edit-time tactics mechanism presented in our work, Lean's
system is very restrictive. It only allows editor action that run on holes, but
our system allows any kind of editor action as long as the user writes the
necessary glue code in the editor mode language. We already showed in
\autoref{code:elispToy}, what the glue code to fill a hole would look like in
Emacs Lisp. Another downside of Lean's system is that editor actions can only
have a single type, as opposed to our system, which allows any kind of
\Elab\ action as long as the components of the a type all have an
\Editorable\ implementation. Our system lets users write more expressive custom
editor actions.

\subsection{Others}

We should also think about the prospects for building editor interactions into
a compiler from the start, so let's take a look at the existing work on
languages that are designed with a priority on editor interactions.

Building editor interactions in a compiler from the start is not a new idea,
both Idris and Agda have done this already. They did not, however, take
metaprogrammable editor interactions into account, and that is what our work
brings to Idris. We believe a path through Racket, a language-oriented
programming~\cite{racketManifesto, feltey2016languages} language would be an
interesting take on building a language around its editor interactions.
DrRacket~\cite{drracket}, Racket's IDE, makes writing editor interaction easy
for the languages defined in Racket. This not only eliminates a lot of
boilerplate code, but it also allows using Racket itself to define new editor
actions. There are already dependently-typed languages defined in Racket: one
example is Cur\footnote{\url{http://github.com/wilbowma/cur}}~\cite{cur}, a proof assistant with
powerful metaprogramming tools.
There is also Pie\footnote{\url{http://github.com/the-little-typer/pie}}~\cite{theLittleTyper}, a
minimal language used for educational purposes.
We believe there is potential
for stronger editor interaction for these languages through metaprogramming.

Another path that is worth exploring more is structure editors. In the proof
assistant world, The Alfa proof editor~\cite{alfa} has established a proof
interface based on a structure editor manipulating proof trees. More recently
the Hazel project~\cite{hazelnut,hazelEditor} explored for a simpler type
theory what a language designed around its editor would look like.
Specifically, they designed a structure editor and a type theory to deal with
incomplete programs in this setting.
% They also coined the term ``edit-time'' to
% mean when the user is writing a program in the editor, and suggested
% ``edit-time tactics'' as future work, by which they
% meant a separate language in which users can define editor actions, and a
% library of predefined editor actions that the users can compose.

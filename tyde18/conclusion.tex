\section{Future Work}

The story of dependently typed languages that can be reprogrammed in
themselves is only just beginning. Further developments can increase
the convenience and reliability of Idris's editor actions.

\subsection{Proof Simplification}
\label{sssec:simplification}

\citet{elabref} showed that elaborator reflection can be used as a
tactic language for interactive theorem proving. It is possible to use
\Elab{} tactics to define custom editor actions and reuse existing
proof automation efforts directly from the editor.

\Elab{} tactics generate a proof term during elaboration, but the
artifact is only a call to the tactic, which allows users to ignore
the proof terms generated by the tactics. However gigantic or hideous
the proof terms are, readers of the code will only see that the
tactics satisfy the goal and they will not see the proof term
itself. Many proof automation procedures such as Coq's
\mt{omega}~\cite{omega} enjoy this leeway.  However, when using
\Elab{} tactics to define custom editor actions, the result of the
action is an expression that is visible to the user. Thus, brevity and
readability are desirable qualities in the proof terms generated by
those tactics.  Requiring all tactic authors to simplify their own
expressions qualities is burdensome, and it hampers the reuse of
existing tactics.  If there were a generic mechanism to simplify and
minimize generated proof terms, and even write them in a way that
makes use of dependent pattern matching, then existing tactics would become
much more useful for implementing editor actions. Ideally, the
artifact handed in to the reader of the user's proofs should be similar
to what it would be without using custom editor actions based on proof
automation.

\subsection{A Universe of Actions}
\label{sssec:universeEncoding}

Section~\ref{ssec:typechecking} described how the Idris compiler
checks whether all components of an editor action type have an
instance of the \Editorable{} type class. However, it is not necessary
to implement this as an additional step during elaboration: it would suffice to
encode the allowed types of editor actions as a universe Ã  la
Tarski~\cite{genericDep}.  The universe type would serve as a wrapper around the
arrow type that checks if the type on the left of the arrow has an
\Editorable{} instance. Figure~\ref{code:universe} shows a possible
universe type and defines a function to map the members of a universe
to their Idris types.

\begin{figure}[b]
\begin{Verbatim}
\kw{data} \ty{Act} : \ty{Type} \kw{where}
  \dt{Done} : (\bn{a} : \ty{Type}) -> \ty{Editorable} \bn{a} => \ty{Act}
  \dt{Arg} : (\bn{a} : \ty{Type}) -> \ty{Editorable} \bn{a} => \ty{Act} -> \ty{Act}

\fn{actTy} : \ty{Act} -> \ty{Type}
\fn{actTy} (\dt{Done} \bn{a}) = \ty{Elab} \bn{a}
\fn{actTy} (\dt{Arg} \bn{a} \bn{e}) = \bn{a} -> \fn{actTy} \bn{e}
\end{Verbatim}
\caption{Universe encoding of types feasible to be treated as editor actions.}
\label{code:universe}
\end{figure}

Figure~\ref{code:universe-example} shows how the type of the \fn{easy} editor
action from figure~\ref{fig:motivating-example} would change with this encoding.

\begin{figure}
\begin{Verbatim}
\fn{easy} : \fn{actTy} (\dt{Arg} \ty{TTName} (\dt{Done} \TT))
\fn{easy} \bn{n} = \cm{\{- elided, same as before -\}}
\end{Verbatim}
\caption{\fn{easy}  rewritten as a universe encoded editor action.}
\label{code:universe-example}
\end{figure}

Observe that \mt{\fn{actTy} (\dt{Arg} \ty{TTName} (\dt{Done} \TT))} evaluates
to \mt{\ty{TTName} -> \Elab{} \TT}, therefore the definition of \fn{easy} does
not have to change.

\subsection{Surface-Language Syntax}

Editor actions presently accept and produce representations of \TT{},
rather than high-level Idris, which greatly simplifies the
implementation and maintenance of editor actions. For many
applications, this does not matter, because the \emph{meaning} of an
expression is more important than how it is written. In some cases,
however, this lack of expressive power might be a problem. For
instance, it is presently impossible to define an editor action that
converts a use of idiom brackets~\citep{Applicative} into the
equivalent \kw{do}-notation, as both expressions have the same
representation in the core language. In the future, it would be
interesting to explore representations of the syntax of high-level
Idris that are robust in the face of change and extension.



\section{Conclusion}\label{sec:conclusion}

In this paper, we extended the capabilities of the editor interaction mode of
Idris by allowing users to define new editor actions in Idris itself. We did
so through a metaprogramming technique that was introduced to Idris recently by
Christiansen and Brady~\cite{elabref}.

Editors communicate with the compiler via S-expressions, so we gave
users the power to dictate how a value of a given Idris type should
exactly be communicated; through the \ty{Editorable} interface users
are now able to define how a received S-expression should be parsed by
the compiler, and how the compiler should send the result as an
S-expression. To achieve this, we reflected the \ty{SExp} type to
Idris, and extended elaborator reflection by adding new \Elab\
primitives, with which we defined the \ty{Editorable} implementations
for Idris types representing the Haskell representation of Idris core
language terms. This demonstrates the value of directly reusing the
compiler's implementations.

We have demonstrated editor actions such as simple proof searches and
a DSL-specific action, as well as a demonstration of rewriting part of
Idris in itself. We hope that Hezarfen will eventually be a better
proof search than the built in action. We believe there is potential
to replace even more of the built-in editor actions with custom editor
actions written in Idris, such as case-splitting and lifting a hole
into a lemma. We can also add new general editor actions such as
renaming a binder, renaming a function within a file, pruning unused
arguments in a function, and so forth.

As the library of elaborator actions grows, more building blocks will
be available for custom editor actions. Even today, however, authors
of libraries and DSLs can include custom editor actions with their
packages, giving library and DSL authors access to power that was
previously reserved for compiler implementors.

If we are serious about type-driven interactive programming, we need
to give users the power to control not only their programming
language, but also their programming environment. Idris's editor
actions are one small step towards that goal.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "source"
%%% End:

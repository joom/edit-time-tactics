\section{Future Work}

The story of dependently typed languages that can be reprogrammed in
themselves is only just beginning. Further developments can increase
the convenience and reliability of Idris's editor actions.

\subsection{Proof Simplification}
\label{sssec:simplification}

\citet{elabref} showed that elaborator reflection can be used as a
tactic language for interactive theorem proving. It is possible to use
\Elab{} tactics to define custom editor actions and reuse existing
proof automation efforts directly from the editor.

\Elab{} tactics generate a proof term during elaboration, but the
artifact is only a call to the tactic, which allows users to ignore
the proof terms generated by the tactics. However gigantic or hideous
the proof terms are, readers of the code will only see that the
tactics satisfy the goal, while the proof term
itself remains hidden. Many well-known proof automation procedures, such as Coq's
\mt{omega}~\cite{omega}, make use of this fact to hide large, complicated proof terms.  However, when using
\Elab{} tactics to define custom editor actions, the result of the
action is an expression that is visible to the user. Thus, brevity and
readability are desirable qualities in the proof terms generated by
those tactics.  Requiring all tactic authors to simplify their own
expressions qualities is burdensome, and it hampers the reuse of
existing tactics.  If there were a generic mechanism to simplify and
minimize generated proof terms, and even write them in a way that
makes use of dependent pattern matching, then existing tactics would become
much more useful for implementing editor actions. Ideally, a finished program that was written with
custom editor actions based on proof automation should be indistinguishable from one written without.

\subsection{A Universe of Actions}
\label{sssec:universeEncoding}

Section~\ref{ssec:typechecking} described how the Idris compiler
checks whether all components of an editor action type have an
instance of the \Editorable{} type class. However, it is not necessary
to implement this as an additional step during elaboration: it would suffice to
encode the allowed types of editor actions as a universe Ã  la
Tarski~\cite{genericDep}.  The universe would include only those functions whose domains
have \Editorable{} instances and whose ranges are in the universe, as well as
other types that have \Editorable{} instances.
Figure~\ref{code:universe} demonstrates an implementation of this universe.


\begin{figure}[H]
\begin{Verbatim}
\kw{data} \ty{Act} : \ty{Type} \kw{where}
  \dt{Done} : (\bn{a} : \ty{Type}) -> \ty{Editorable} \bn{a} => \ty{Act}
  \dt{Arg} : (\bn{a} : \ty{Type}) -> \ty{Editorable} \bn{a} =>
     (\bn{a} -> \ty{Act}) -> \ty{Act}

\fn{actTy} : \ty{Act} -> \ty{Type}
\fn{actTy} (\dt{Done} \bn{ty}) = \ty{Elab} \bn{ty}
\fn{actTy} (\dt{Arg} \bn{ty} \bn{f}) = (\bn{v} : \bn{ty}) -> \fn{actTy} (\bn{f} \bn{v})
\end{Verbatim}
\caption{Universe encoding of types feasible to be treated as editor actions.}
\label{code:universe}
\end{figure}

Figure~\ref{code:universe-example} shows how the type of the \fn{easy} editor
action from figure~\ref{fig:motivating-example} would change with this encoding.

\begin{figure}[H]
\begin{Verbatim}
\fn{easy} : \fn{actTy} (\dt{Arg} \ty{TTName} (\textbackslash\bn{n} => \dt{Done} \TT))
\fn{easy} \bn{n} = \cm{\{- elided, same as before -\}}
\end{Verbatim}
\caption{\fn{easy} rewritten as a universe encoded editor action.}
\label{code:universe-example}
\end{figure}

Observe that \mt{\fn{actTy} (\dt{Arg} \ty{TTName} (\dt{Done} \TT))} evaluates
to \mt{\ty{TTName} -> \Elab{} \TT}, therefore the definition of \fn{easy} does
not have to change.

The most important outcome of this change would be the increase in the
expressiveness of editor action types. The current implementation rules out
dependently typed editor actions, while this universe encoding would allow
them. Figure ~\ref{code:universe-dependent} shows a
hypothetical editor action that takes a vector of some length that contains
function names and returns a vector of the \emph{same} length that contains the types
found for the function names.

\begin{figure}[H]
\begin{Verbatim}
\fn{getTypes} : \fn{actTy} (\dt{Arg} \ty{Nat} (\textbackslash\bn{n} =>
                    \dt{Arg} (\ty{Vect} \bn{n} \ty{TTName}) (\textbackslash{}_ =>
                      \dt{Done} (\ty{Vect} \bn{n} (\ty{Maybe} \ty{TT})))))
\fn{getTypes} \bn{n} \bn{v} =
  \fn{for} \bn{v} (\textbackslash\bn{n} =>
    \kw{do} \bn{l} <- \fn{lookupTy} \bn{n}
       \kw{case} \bn{l} \kw{of}
         \dt{[(}_\dt{,} _\dt{,} \bn{ty}\dt{)]} => \fn{pure} (\dt{Just} \bn{ty})
         _ => \fn{pure} \dt{Nothing})
\end{Verbatim}
\caption{A dependently typed editor action that would be possible with the universe encoding.}
\label{code:universe-dependent}
\end{figure}

% I'm not sure if we need this paragraph... we can remove it later
However, writing editor actions with dependent data types would require writing
more complex \Editorable{} instances.  Figure ~\ref{code:editorable-vect} shows the
\Editorable{} instance for length-indexed vectors, which uses lists to denote
vectors and hence has to check if the lengths match in every deserialization.
\citet{foundations-dep-interop} provide a solution to this problem that could be
adopted in Idris.

\begin{figure}[H]
\begin{Verbatim}
\kw{implementation} \ty{Editorable} \bn{a}
            => \ty{Editorable} (\ty{Vect} \bn{n} \bn{a}) \kw{where}
  \fn{fromEditor} \{\bn{a}\} \{\bn{n}\} (\dt{SExpList} \bn{l}) =
    \kw{do} \bn{l'} <- \fn{traverse} (\fn{fromEditor} \{a = \bn{a}\}) \bn{l}
             \fn{<|>} \fn{fail} \dt{[}\cm{\{- elided -\}}\dt{]}
       \kw{case} \fn{decEq} (\fn{length} \bn{l'}) \bn{n} \kw{of}
         \dt{Yes} \bn{pf} =>
           \fn{pure} (\fn{replace} \{P = \textbackslash{}\bn{k} => \ty{Vect} \bn{k} \bn{a}\}
                         \bn{pf} (\fn{fromList} \bn{l'}))
         \dt{No} _ => \fn{fail} \dt{[}\cm{\{- elided -\}}\dt{]}
  \fn{fromEditor} _ = \fn{fail} \dt{[}\cm{\{- elided -\}}\dt{]}
  \fn{toEditor} \bn{v} = \fn{toEditor} (\fn{toList} \bn{v})
\end{Verbatim}
\caption{\Editorable{} instance for length-indexed vectors.}
\label{code:editorable-vect}
\end{figure}

\subsection{Surface-Language Syntax}

Editor actions presently accept and produce representations of \TT{},
rather than high-level Idris, which greatly simplifies the
implementation and maintenance of editor actions. For many
applications, this does not matter, because the \emph{meaning} of an
expression is more important than how it is written. In some cases,
however, this lack of expressive power might be a problem. For
instance, it is presently impossible to define an editor action that
converts a use of idiom brackets~\citep{Applicative} into the
equivalent \kw{do}-notation, as both expressions have the same
representation in the core language. In the future, it would be
interesting to explore representations of the syntax of high-level
Idris that are robust in the face of change and extension.



\section{Conclusion}\label{sec:conclusion}

In this paper, we extended the capabilities of the editor interaction mode of
Idris by allowing users to define new editor actions in Idris itself. We did
so through a metaprogramming technique that was introduced to Idris recently by
Christiansen and Brady~\cite{elabref}.

Editors communicate with the compiler via S-expressions, so we gave
users the power to dictate how a value of a given Idris type should
exactly be communicated; through the \ty{Editorable} interface users
are now able to define how a received S-expression should be parsed by
the compiler, and how the compiler should send the result as an
S-expression. To achieve this, we reflected the \ty{SExp} type to
Idris, and extended elaborator reflection by adding new \Elab\
primitives, with which we defined the \ty{Editorable} implementations
for Idris types representing the Haskell representation of Idris core
language terms. This demonstrates the value of directly reusing the
compiler's implementations.

We have demonstrated editor actions such as simple proof searches and
a DSL-specific action, as well as a demonstration of rewriting part of
Idris in itself. We hope that Hezarfen will eventually be a better
proof search than the built in action. We believe there is potential
to replace even more of the built-in editor actions with custom editor
actions written in Idris, such as case-splitting and lifting a hole
into a lemma. We can also add new general editor actions such as
renaming a binder, renaming a function within a file, pruning unused
arguments in a function, and so forth.

As the library of elaborator actions grows, more building blocks will
be available for custom editor actions. Even today, however, authors
of libraries and DSLs can include custom editor actions with their
packages, giving library and DSL authors access to power that was
previously reserved for compiler implementors.

If we are serious about type-driven interactive programming, we need
to give users the power to control not only their programming
language, but also their programming environment. Idris's editor
actions are one small step towards that goal.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "source"
%%% End:
